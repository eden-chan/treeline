"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InstantReact = exports.InstantReactRoom = exports.defaultActivityStopTimeout = void 0;
const core_1 = require("@instantdb/core");
const react_1 = require("react");
const useQuery_1 = require("./useQuery");
const useTimeout_1 = require("./useTimeout");
exports.defaultActivityStopTimeout = 1000;
class InstantReactRoom {
    constructor(_core, type, id) {
        /**
         * Listen for broadcasted events given a room and topic.
         *
         * @see https://instantdb.com/docs/presence-and-topics
         * @example
         *  function App({ roomId }) {
         *    db.room(roomType, roomId).useTopicEffect("chat", (message, peer) => {
         *      console.log("New message", message, 'from', peer.name);
         *    });
         *
         *    // ...
         *  }
         */
        this.useTopicEffect = (topic, onEvent) => {
            (0, react_1.useEffect)(() => {
                const unsub = this._core._reactor.subscribeTopic(this.id, topic, (event, peer) => {
                    onEvent(event, peer);
                });
                return unsub;
            }, [this.id, topic]);
        };
        /**
         * Broadcast an event to a room.
         *
         * @see https://instantdb.com/docs/presence-and-topics
         * @example
         * function App({ roomId }) {
         *   const publishTopic = db.room(roomType, roomId).usePublishTopic("clicks");
         *
         *   return (
         *     <button onClick={() => publishTopic({ ts: Date.now() })}>Click me</button>
         *   );
         * }
         *
         */
        this.usePublishTopic = (topic) => {
            (0, react_1.useEffect)(() => this._core._reactor.joinRoom(this.id), [this.id]);
            const publishTopic = (0, react_1.useCallback)((data) => {
                this._core._reactor.publishTopic({
                    roomType: this.type,
                    roomId: this.id,
                    topic,
                    data,
                });
            }, [this.id, topic]);
            return publishTopic;
        };
        /**
         * Listen for peer's presence data in a room, and publish the current user's presence.
         *
         * @see https://instantdb.com/docs/presence-and-topics
         * @example
         *  function App({ roomId }) {
         *    const {
         *      peers,
         *      publishPresence
         *    } = db.room(roomType, roomId).usePresence({ keys: ["name", "avatar"] });
         *
         *    // ...
         *  }
         */
        this.usePresence = (opts = {}) => {
            var _a, _b;
            const [state, setState] = (0, react_1.useState)(() => {
                var _a;
                return ((_a = this._core._reactor.getPresence(this.type, this.id, opts)) !== null && _a !== void 0 ? _a : {
                    peers: {},
                    isLoading: true,
                });
            });
            (0, react_1.useEffect)(() => {
                const unsub = this._core._reactor.subscribePresence(this.type, this.id, opts, (data) => {
                    setState(data);
                });
                return unsub;
            }, [this.id, opts.user, (_a = opts.peers) === null || _a === void 0 ? void 0 : _a.join(), (_b = opts.keys) === null || _b === void 0 ? void 0 : _b.join()]);
            return Object.assign(Object.assign({}, state), { publishPresence: (data) => {
                    this._core._reactor.publishPresence(this.type, this.id, data);
                } });
        };
        /**
         * Publishes presence data to a room
         *
         * @see https://instantdb.com/docs/presence-and-topics
         * @example
         *  function App({ roomId }) {
         *    db.room(roomType, roomId).useSyncPresence({ name, avatar, color });
         *
         *    // ...
         *  }
         */
        this.useSyncPresence = (data, deps) => {
            (0, react_1.useEffect)(() => this._core._reactor.joinRoom(this.id), [this.id]);
            (0, react_1.useEffect)(() => {
                return this._core._reactor.publishPresence(this.type, this.id, data);
            }, [this.type, this.id, deps !== null && deps !== void 0 ? deps : JSON.stringify(data)]);
        };
        /**
         * Manage typing indicator state
         *
         * @see https://instantdb.com/docs/presence-and-topics
         * @example
         *  function App({ roomId }) {
         *    const {
         *      active,
         *      setActive,
         *      inputProps,
         *    } = db.room(roomType, roomId).useTypingIndicator("chat-input", opts);
         *
         *    return <input {...inputProps} />;
         *  }
         */
        this.useTypingIndicator = (inputName, opts = {}) => {
            const timeout = (0, useTimeout_1.useTimeout)();
            const onservedPresence = this.usePresence({
                keys: [inputName],
            });
            const active = (0, react_1.useMemo)(() => {
                var _a;
                const presenceSnapshot = this._core._reactor.getPresence(this.type, this.id);
                return (opts === null || opts === void 0 ? void 0 : opts.writeOnly)
                    ? []
                    : Object.values((_a = presenceSnapshot === null || presenceSnapshot === void 0 ? void 0 : presenceSnapshot.peers) !== null && _a !== void 0 ? _a : {}).filter((p) => p[inputName] === true);
            }, [opts === null || opts === void 0 ? void 0 : opts.writeOnly, onservedPresence]);
            const setActive = (isActive) => {
                var _a;
                this._core._reactor.publishPresence(this.type, this.id, {
                    [inputName]: isActive,
                });
                if (!isActive)
                    return;
                if ((opts === null || opts === void 0 ? void 0 : opts.timeout) === null || (opts === null || opts === void 0 ? void 0 : opts.timeout) === 0)
                    return;
                timeout.set((_a = opts === null || opts === void 0 ? void 0 : opts.timeout) !== null && _a !== void 0 ? _a : exports.defaultActivityStopTimeout, () => {
                    this._core._reactor.publishPresence(this.type, this.id, {
                        [inputName]: null,
                    });
                });
            };
            return {
                active,
                setActive: (a) => {
                    setActive(a);
                },
                inputProps: {
                    onKeyDown: (e) => {
                        const isEnter = (opts === null || opts === void 0 ? void 0 : opts.stopOnEnter) && e.key === "Enter";
                        const isActive = !isEnter;
                        setActive(isActive);
                    },
                    onBlur: () => {
                        setActive(false);
                    },
                },
            };
        };
        this._core = _core;
        this.type = type;
        this.id = id;
    }
}
exports.InstantReactRoom = InstantReactRoom;
const defaultAuthState = {
    isLoading: true,
    user: undefined,
    error: undefined,
};
class InstantReact {
    constructor(config) {
        this.tx = (0, core_1.txInit)();
        this.getLocalId = (name) => {
            return this._core.getLocalId(name);
        };
        /**
         * Use this to write data! You can create, update, delete, and link objects
         *
         * @see https://instantdb.com/docs/instaml
         *
         * @example
         *   // Create a new object in the `goals` namespace
         *   const goalId = id();
         *   db.transact(tx.goals[goalId].update({title: "Get fit"}))
         *
         *   // Update the title
         *   db.transact(tx.goals[goalId].update({title: "Get super fit"}))
         *
         *   // Delete it
         *   db.transact(tx.goals[goalId].delete())
         *
         *   // Or create an association:
         *   todoId = id();
         *   db.transact([
         *    tx.todos[todoId].update({ title: 'Go on a run' }),
         *    tx.goals[goalId].link({todos: todoId}),
         *  ])
         */
        this.transact = (chunks) => {
            return this._core.transact(chunks);
        };
        /**
         * Use this to query your data!
         *
         * @see https://instantdb.com/docs/instaql
         *
         * @example
         *  // listen to all goals
         *  db.useQuery({ goals: {} })
         *
         *  // goals where the title is "Get Fit"
         *  db.useQuery({ goals: { $: { where: { title: "Get Fit" } } } })
         *
         *  // all goals, _alongside_ their todos
         *  db.useQuery({ goals: { todos: {} } })
         *
         *  // skip if `user` is not logged in
         *  db.useQuery(auth.user ? { goals: {} } : null)
         */
        this.useQuery = (query) => {
            return (0, useQuery_1.useQuery)(this._core, query).state;
        };
        /**
         * Listen for the logged in state. This is useful
         * for deciding when to show a login screen.
         *
         * Check out the docs for an example `Login` component too!
         *
         * @see https://instantdb.com/docs/auth
         * @example
         *  function App() {
         *    const { isLoading, user, error } = db.useAuth()
         *    if (isLoading) {
         *      return <div>Loading...</div>
         *    }
         *    if (error) {
         *      return <div>Uh oh! {error.message}</div>
         *    }
         *    if (user) {
         *      return <Main user={user} />
         *    }
         *    return <Login />
         *  }
         *
         */
        this.useAuth = () => {
            // We use a ref to store the result of the query.
            // This is becuase `useSyncExternalStore` uses `Object.is`
            // to compare the previous and next state.
            // If we don't use a ref, the state will always be considered different, so
            // the component will always re-render.
            const resultCacheRef = (0, react_1.useRef)(this._core._reactor._currentUserCached);
            // Similar to `resultCacheRef`, `useSyncExternalStore` will unsubscribe
            // if `subscribe` changes, so we use `useCallback` to memoize the function.
            const subscribe = (0, react_1.useCallback)((cb) => {
                const unsubscribe = this._core.subscribeAuth((auth) => {
                    resultCacheRef.current = Object.assign({ isLoading: false }, auth);
                    cb();
                });
                return unsubscribe;
            }, []);
            const state = (0, react_1.useSyncExternalStore)(subscribe, () => resultCacheRef.current, () => defaultAuthState);
            return state;
        };
        /**
         * Use this for one-off queries.
         * Returns local data if available, otherwise fetches from the server.
         * Because we want to avoid stale data, this method will throw an error
         * if the user is offline or there is no active connection to the server.
         *
         * @see https://instantdb.com/docs/instaql
         *
         * @example
         *
         *  const resp = await db.queryOnce({ goals: {} });
         *  console.log(resp.data.goals)
         */
        this.queryOnce = (query) => {
            return this._core.queryOnce(query);
        };
        this._core = (0, core_1._init_internal)(config, 
        // @ts-expect-error because TS can't resolve subclass statics
        this.constructor.Storage, 
        // @ts-expect-error because TS can't resolve subclass statics
        this.constructor.NetworkListener);
        this.auth = this._core.auth;
        this.storage = this._core.storage;
    }
    /**
     * Obtain a handle to a room, which allows you to listen to topics and presence data
     *
     * If you don't provide a `type` or `id`, Instant will default to `_defaultRoomType` and `_defaultRoomId`
     * as the room type and id, respectively.
     *
     * @see https://instantdb.com/docs/presence-and-topics
     *
     * @example
     *  const {
     *   useTopicEffect,
     *   usePublishTopic,
     *   useSyncPresence,
     *   useTypingIndicator,
     * } = db.room(roomType, roomId);
     */
    room(type = "_defaultRoomType", id = "_defaultRoomId") {
        return new InstantReactRoom(this._core, type, id);
    }
}
exports.InstantReact = InstantReact;
//# sourceMappingURL=InstantReact.js.map