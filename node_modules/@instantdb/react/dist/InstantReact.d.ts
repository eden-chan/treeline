import { InstantClient, Auth, Storage, type AuthState, type Config, type Query, type Exactly, type TransactionChunk, type LifecycleSubscriptionState, type PresenceOpts, type PresenceResponse, type RoomSchemaShape, type InstaQLQueryParams, type ConfigWithSchema, type IDatabase, type InstantGraph, type QueryResponse, type PageInfoResponse } from "@instantdb/core";
import { KeyboardEvent } from "react";
export type PresenceHandle<PresenceShape, Keys extends keyof PresenceShape> = PresenceResponse<PresenceShape, Keys> & {
    publishPresence: (data: Partial<PresenceShape>) => void;
};
export type TypingIndicatorOpts = {
    timeout?: number | null;
    stopOnEnter?: boolean;
    writeOnly?: boolean;
};
export type TypingIndicatorHandle<PresenceShape> = {
    active: PresenceShape[];
    setActive(active: boolean): void;
    inputProps: {
        onKeyDown: (e: KeyboardEvent) => void;
        onBlur: () => void;
    };
};
export declare const defaultActivityStopTimeout = 1000;
export declare class InstantReactRoom<Schema extends InstantGraph<any, any> | {}, RoomSchema extends RoomSchemaShape, RoomType extends keyof RoomSchema> {
    _core: InstantClient<Schema, RoomSchema>;
    type: RoomType;
    id: string;
    constructor(_core: InstantClient<Schema, RoomSchema, any>, type: RoomType, id: string);
    /**
     * Listen for broadcasted events given a room and topic.
     *
     * @see https://instantdb.com/docs/presence-and-topics
     * @example
     *  function App({ roomId }) {
     *    db.room(roomType, roomId).useTopicEffect("chat", (message, peer) => {
     *      console.log("New message", message, 'from', peer.name);
     *    });
     *
     *    // ...
     *  }
     */
    useTopicEffect: <TopicType extends keyof RoomSchema[RoomType]["topics"]>(topic: TopicType, onEvent: (event: RoomSchema[RoomType]["topics"][TopicType], peer: RoomSchema[RoomType]["presence"]) => any) => void;
    /**
     * Broadcast an event to a room.
     *
     * @see https://instantdb.com/docs/presence-and-topics
     * @example
     * function App({ roomId }) {
     *   const publishTopic = db.room(roomType, roomId).usePublishTopic("clicks");
     *
     *   return (
     *     <button onClick={() => publishTopic({ ts: Date.now() })}>Click me</button>
     *   );
     * }
     *
     */
    usePublishTopic: <Topic extends keyof RoomSchema[RoomType]["topics"]>(topic: Topic) => ((data: RoomSchema[RoomType]["topics"][Topic]) => void);
    /**
     * Listen for peer's presence data in a room, and publish the current user's presence.
     *
     * @see https://instantdb.com/docs/presence-and-topics
     * @example
     *  function App({ roomId }) {
     *    const {
     *      peers,
     *      publishPresence
     *    } = db.room(roomType, roomId).usePresence({ keys: ["name", "avatar"] });
     *
     *    // ...
     *  }
     */
    usePresence: <Keys extends keyof RoomSchema[RoomType]["presence"]>(opts?: PresenceOpts<RoomSchema[RoomType]["presence"], Keys>) => PresenceHandle<RoomSchema[RoomType]["presence"], Keys>;
    /**
     * Publishes presence data to a room
     *
     * @see https://instantdb.com/docs/presence-and-topics
     * @example
     *  function App({ roomId }) {
     *    db.room(roomType, roomId).useSyncPresence({ name, avatar, color });
     *
     *    // ...
     *  }
     */
    useSyncPresence: (data: Partial<RoomSchema[RoomType]["presence"]>, deps?: any[]) => void;
    /**
     * Manage typing indicator state
     *
     * @see https://instantdb.com/docs/presence-and-topics
     * @example
     *  function App({ roomId }) {
     *    const {
     *      active,
     *      setActive,
     *      inputProps,
     *    } = db.room(roomType, roomId).useTypingIndicator("chat-input", opts);
     *
     *    return <input {...inputProps} />;
     *  }
     */
    useTypingIndicator: (inputName: string, opts?: TypingIndicatorOpts) => TypingIndicatorHandle<RoomSchema[RoomType]["presence"]>;
}
export declare abstract class InstantReact<Schema extends InstantGraph<any, any> | {} = {}, RoomSchema extends RoomSchemaShape = {}, WithCardinalityInference extends boolean = false> implements IDatabase<Schema, RoomSchema, WithCardinalityInference> {
    withCardinalityInference?: WithCardinalityInference;
    tx: import("@instantdb/core").TxChunk<Schema extends InstantGraph<any, any, {}> ? Schema : InstantGraph<any, any, {}>>;
    auth: Auth;
    storage: Storage;
    _core: InstantClient<Schema, RoomSchema, WithCardinalityInference>;
    static Storage?: any;
    static NetworkListener?: any;
    constructor(config: Config | ConfigWithSchema<any>);
    getLocalId: (name: string) => Promise<string>;
    /**
     * Obtain a handle to a room, which allows you to listen to topics and presence data
     *
     * If you don't provide a `type` or `id`, Instant will default to `_defaultRoomType` and `_defaultRoomId`
     * as the room type and id, respectively.
     *
     * @see https://instantdb.com/docs/presence-and-topics
     *
     * @example
     *  const {
     *   useTopicEffect,
     *   usePublishTopic,
     *   useSyncPresence,
     *   useTypingIndicator,
     * } = db.room(roomType, roomId);
     */
    room<RoomType extends keyof RoomSchema>(type?: RoomType, id?: string): InstantReactRoom<Schema, RoomSchema, RoomType>;
    /**
     * Use this to write data! You can create, update, delete, and link objects
     *
     * @see https://instantdb.com/docs/instaml
     *
     * @example
     *   // Create a new object in the `goals` namespace
     *   const goalId = id();
     *   db.transact(tx.goals[goalId].update({title: "Get fit"}))
     *
     *   // Update the title
     *   db.transact(tx.goals[goalId].update({title: "Get super fit"}))
     *
     *   // Delete it
     *   db.transact(tx.goals[goalId].delete())
     *
     *   // Or create an association:
     *   todoId = id();
     *   db.transact([
     *    tx.todos[todoId].update({ title: 'Go on a run' }),
     *    tx.goals[goalId].link({todos: todoId}),
     *  ])
     */
    transact: (chunks: TransactionChunk<any, any> | TransactionChunk<any, any>[]) => Promise<import("@instantdb/core").TransactionResult>;
    /**
     * Use this to query your data!
     *
     * @see https://instantdb.com/docs/instaql
     *
     * @example
     *  // listen to all goals
     *  db.useQuery({ goals: {} })
     *
     *  // goals where the title is "Get Fit"
     *  db.useQuery({ goals: { $: { where: { title: "Get Fit" } } } })
     *
     *  // all goals, _alongside_ their todos
     *  db.useQuery({ goals: { todos: {} } })
     *
     *  // skip if `user` is not logged in
     *  db.useQuery(auth.user ? { goals: {} } : null)
     */
    useQuery: <Q extends Schema extends InstantGraph<any, any> ? InstaQLQueryParams<Schema> : Exactly<Query, Q>>(query: null | Q) => LifecycleSubscriptionState<Q, Schema, WithCardinalityInference>;
    /**
     * Listen for the logged in state. This is useful
     * for deciding when to show a login screen.
     *
     * Check out the docs for an example `Login` component too!
     *
     * @see https://instantdb.com/docs/auth
     * @example
     *  function App() {
     *    const { isLoading, user, error } = db.useAuth()
     *    if (isLoading) {
     *      return <div>Loading...</div>
     *    }
     *    if (error) {
     *      return <div>Uh oh! {error.message}</div>
     *    }
     *    if (user) {
     *      return <Main user={user} />
     *    }
     *    return <Login />
     *  }
     *
     */
    useAuth: () => AuthState;
    /**
     * Use this for one-off queries.
     * Returns local data if available, otherwise fetches from the server.
     * Because we want to avoid stale data, this method will throw an error
     * if the user is offline or there is no active connection to the server.
     *
     * @see https://instantdb.com/docs/instaql
     *
     * @example
     *
     *  const resp = await db.queryOnce({ goals: {} });
     *  console.log(resp.data.goals)
     */
    queryOnce: <Q extends Schema extends InstantGraph<any, any> ? InstaQLQueryParams<Schema> : Exactly<Query, Q>>(query: Q) => Promise<{
        data: QueryResponse<Q, Schema, WithCardinalityInference>;
        pageInfo: PageInfoResponse<Q>;
    }>;
}
//# sourceMappingURL=InstantReact.d.ts.map