"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useQuery = useQuery;
const core_1 = require("@instantdb/core");
const react_1 = require("react");
const defaultState = {
    isLoading: true,
    data: undefined,
    pageInfo: undefined,
    error: undefined,
};
function stateForResult(result) {
    return Object.assign({ isLoading: !Boolean(result), data: undefined, pageInfo: undefined, error: undefined }, (result ? result : {}));
}
function useQuery(_core, _query) {
    const query = _query ? (0, core_1.coerceQuery)(_query) : null;
    const queryHash = (0, core_1.weakHash)(query);
    // We use a ref to store the result of the query.
    // This is becuase `useSyncExternalStore` uses `Object.is`
    // to compare the previous and next state.
    // If we don't use a ref, the state will always be considered different, so
    // the component will always re-render.
    const resultCacheRef = (0, react_1.useRef)(stateForResult(_core._reactor.getPreviousResult(query)));
    // Similar to `resultCacheRef`, `useSyncExternalStore` will unsubscribe
    // if `subscribe` changes, so we use `useCallback` to memoize the function.
    const subscribe = (0, react_1.useCallback)((cb) => {
        // Don't subscribe if query is null
        if (!query) {
            const unsubscribe = () => { };
            return unsubscribe;
        }
        const unsubscribe = _core.subscribeQuery(query, (result) => {
            resultCacheRef.current = Object.assign({ isLoading: !Boolean(result), data: undefined, pageInfo: undefined, error: undefined }, result);
            cb();
        });
        return unsubscribe;
    }, 
    // Build a new subscribe function if the query changes
    [queryHash]);
    const state = (0, react_1.useSyncExternalStore)(subscribe, () => resultCacheRef.current, () => defaultState);
    return { state, query };
}
//# sourceMappingURL=useQuery.js.map