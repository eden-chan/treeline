{"version":3,"file":"queryTypes.js","sourceRoot":"","sources":["../src/queryTypes.ts"],"names":[],"mappings":";AAAA,QAAQ;AACR,QAAQ","sourcesContent":["// Query\n// -----\n\nimport { IDatabase } from \"./coreTypes\";\nimport type {\n  EntitiesDef,\n  InstantGraph,\n  LinkAttrDef,\n  ResolveAttrs,\n} from \"./schemaTypes\";\n\n// NonEmpty disallows {}, so that you must provide at least one field\ntype NonEmpty<T> = {\n  [K in keyof T]-?: Required<Pick<T, K>>;\n}[keyof T];\n\ntype WhereArgs = {\n  in?: (string | number | boolean)[];\n};\n\ntype WhereClauseValue = string | number | boolean | NonEmpty<WhereArgs>;\n\ntype BaseWhereClause = {\n  [key: string]: WhereClauseValue;\n};\n\ntype WhereClauseWithCombination = {\n  or?: WhereClause[] | WhereClauseValue;\n  and?: WhereClause[] | WhereClauseValue;\n};\n\ntype WhereClause =\n  | WhereClauseWithCombination\n  | (WhereClauseWithCombination & BaseWhereClause);\n\n/**\n * A tuple representing a cursor.\n * These should not be constructed manually. The current format\n * is an implementation detail that may change in the future.\n * Use the `endCursor` or `startCursor` from the PageInfoResponse as the\n * `before` or `after` field in the query options.\n */\ntype Cursor = [string, string, any, number];\n\ntype Direction = \"asc\" | \"desc\";\n\ntype Order = { serverCreatedAt: Direction };\n\ntype $Option = {\n  $?: {\n    where?: WhereClause;\n    order?: Order;\n    limit?: number;\n    last?: number;\n    first?: number;\n    offset?: number;\n    after?: Cursor;\n    before?: Cursor;\n  };\n};\n\ntype Subquery = { [namespace: string]: NamespaceVal };\n\ntype NamespaceVal = $Option | ($Option & Subquery);\n\ninterface Query {\n  [namespace: string]: NamespaceVal;\n}\n\ntype InstantObject = {\n  id: string;\n  [prop: string]: any;\n};\n\ntype ResponseObject<K, Schema> = K extends keyof Schema\n  ? { id: string } & Schema[K]\n  : InstantObject;\n\ntype IsEmptyObject<T> = T extends Record<string, never> ? true : false;\n\ntype ResponseOf<Q, Schema> = {\n  [K in keyof Q]: IsEmptyObject<Q[K]> extends true\n    ? ResponseObject<K, Schema>[]\n    : (ResponseOf<Q[K], Schema> & ResponseObject<K, Schema>)[];\n};\n\ntype Remove$<T> = T extends object\n  ? { [K in keyof T as Exclude<K, \"$\">]: Remove$<T[K]> }\n  : T;\n\ntype QueryResponse<\n  Q,\n  Schema,\n  WithCardinalityInference extends boolean = false,\n> =\n  Schema extends InstantGraph<infer E, any>\n    ? InstaQLQueryResult<E, Q, WithCardinalityInference>\n    : ResponseOf<{ [K in keyof Q]: Remove$<Q[K]> }, Schema>;\n\ntype PageInfoResponse<T> = {\n  [K in keyof T]: {\n    startCursor: Cursor;\n    endCursor: Cursor;\n    hasNextPage: boolean;\n    hasPreviousPage: boolean;\n  };\n};\n\n/**\n * (XXX)\n * https://github.com/microsoft/TypeScript/issues/26051\n *\n * Typescript can permit extra keys when a generic extends a type.\n *\n * For some reason, it makes it possible to write a query like so:\n *\n * dummyQuery({\n *  users: {\n *    $: { where: { \"foo\": 1 } },\n *    posts: {\n *      $: { \"far\": {} }\n *    }\n *  }\n *\n *  The problem: $: { \"far\": {} }\n *\n *  This passes, when it should in reality fail. I don't know why\n *  adding `Exactly` fixes this, but it does.\n *\n * */\ntype Exactly<Parent, Child> = Parent & {\n  [K in keyof Child]: K extends keyof Parent ? Child[K] : never;\n};\n\n// ==========\n// InstaQL helpers\n\ntype InstaQLQueryEntityLinksResult<\n  Entities extends EntitiesDef,\n  EntityName extends keyof Entities,\n  Query extends {\n    [LinkAttrName in keyof Entities[EntityName][\"links\"]]?: any;\n  },\n  WithCardinalityInference extends boolean,\n> = {\n  [QueryPropName in keyof Query]: Entities[EntityName][\"links\"][QueryPropName] extends LinkAttrDef<\n    infer Cardinality,\n    infer LinkedEntityName\n  >\n    ? LinkedEntityName extends keyof Entities\n      ? WithCardinalityInference extends true\n        ? Cardinality extends \"one\"\n          ?\n              | InstaQLQueryEntityResult<\n                  Entities,\n                  LinkedEntityName,\n                  Query[QueryPropName],\n                  WithCardinalityInference\n                >\n              | undefined\n          : InstaQLQueryEntityResult<\n              Entities,\n              LinkedEntityName,\n              Query[QueryPropName],\n              WithCardinalityInference\n            >[]\n        : InstaQLQueryEntityResult<\n            Entities,\n            LinkedEntityName,\n            Query[QueryPropName],\n            WithCardinalityInference\n          >[]\n      : never\n    : never;\n};\n\ntype InstaQLQueryEntityResult<\n  Entities extends EntitiesDef,\n  EntityName extends keyof Entities,\n  Query extends {\n    [QueryPropName in keyof Entities[EntityName][\"links\"]]?: any;\n  },\n  WithCardinalityInference extends boolean,\n> = { id: string } & ResolveAttrs<Entities, EntityName> &\n  InstaQLQueryEntityLinksResult<\n    Entities,\n    EntityName,\n    Query,\n    WithCardinalityInference\n  >;\n\ntype InstaQLQueryResult<\n  Entities extends EntitiesDef,\n  Query,\n  WithCardinalityInference extends boolean,\n> = {\n  [QueryPropName in keyof Query]: QueryPropName extends keyof Entities\n    ? InstaQLQueryEntityResult<\n        Entities,\n        QueryPropName,\n        Query[QueryPropName],\n        WithCardinalityInference\n      >[]\n    : never;\n};\n\ntype InstaQLQuerySubqueryParams<\n  S extends InstantGraph<any, any>,\n  E extends keyof S[\"entities\"],\n> = {\n  [K in keyof S[\"entities\"][E][\"links\"]]?:\n    | $Option\n    | ($Option &\n        InstaQLQuerySubqueryParams<\n          S,\n          S[\"entities\"][E][\"links\"][K][\"entityName\"]\n        >);\n};\n\ntype InstaQLQueryParams<S extends InstantGraph<any, any>> = {\n  [K in keyof S[\"entities\"]]?:\n    | $Option\n    | ($Option & InstaQLQuerySubqueryParams<S, K>);\n};\n\nexport {\n  Query,\n  QueryResponse,\n  PageInfoResponse,\n  InstantObject,\n  Exactly,\n  Remove$,\n  InstaQLQueryResult,\n  InstaQLQueryParams,\n  InstaQLQueryEntityResult,\n  Cursor,\n};\n"]}