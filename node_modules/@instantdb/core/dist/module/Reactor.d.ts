/**
 * @template {import('./presence').RoomSchemaShape} [RoomSchema = {}]
 */
export default class Reactor<RoomSchema extends import("./presence").RoomSchemaShape = {}> {
    constructor(config: any, Storage?: typeof IndexedDBStorage, NetworkListener?: typeof WindowNetworkListener);
    attrs: any;
    _isOnline: boolean;
    _isShutdown: boolean;
    status: string;
    /** @type {PersistedObject} */
    querySubs: PersistedObject;
    /** @type {PersistedObject} */
    pendingMutations: PersistedObject;
    /** @type {Record<string, Array<{ q: any, cb: (data: any) => any }>>} */
    queryCbs: Record<string, Array<{
        q: any;
        cb: (data: any) => any;
    }>>;
    /** @type {Record<string, Array<{ q: any, eventId: string, dfd: Deferred }>>} */
    queryOnceDfds: Record<string, Array<{
        q: any;
        eventId: string;
        dfd: Deferred;
    }>>;
    authCbs: any[];
    attrsCbs: any[];
    mutationErrorCbs: any[];
    config: any;
    _persister: any;
    mutationDeferredStore: Map<any, any>;
    _reconnectTimeoutId: any;
    _reconnectTimeoutMs: number;
    _ws: any;
    _localIdPromises: {};
    _errorMessage: any;
    /** @type {Promise<null | {error: {message: string}}>}**/
    _oauthCallbackResponse: Promise<null | {
        error: {
            message: string;
        };
    }>;
    /** @type {null | import('./utils/linkIndex').LinkIndex}} */
    _linkIndex: null | import("./utils/linkIndex").LinkIndex;
    /** @type BroadcastChannel | undefined */
    _broadcastChannel: BroadcastChannel | undefined;
    /** @type {Record<string, {isConnected: boolean; error: any}>} */
    _rooms: Record<string, {
        isConnected: boolean;
        error: any;
    }>;
    /** @type {Record<string, boolean>} */
    _roomsPendingLeave: Record<string, boolean>;
    _presence: {};
    _broadcastQueue: any[];
    _broadcastSubs: {};
    _currentUserCached: {
        isLoading: boolean;
        error: any;
        user: any;
    };
    _beforeUnloadCbs: any[];
    _dataForQueryCache: {};
    _beforeUnload(): void;
    _initStorage(Storage: any): void;
    /**
     * @param {'enqueued' | 'pending' | 'synced' | 'timeout' |  'error' } status
     * @param string clientId
     * @param {{message?: string, hint?: string, error?: Error}} [errDetails]
     */
    _finishTransaction(status: "enqueued" | "pending" | "synced" | "timeout" | "error", clientId: any, errDetails?: {
        message?: string;
        hint?: string;
        error?: Error;
    }): void;
    _setStatus(status: any, err: any): void;
    /**
     *  merge querySubs from storage and in memory. Has the following side
     *  effects:
     *  - We notify all queryCbs because results may been added during merge
     */
    _onMergeQuerySubs: (_storageSubs: any, inMemorySubs: any) => void;
    /**
     * merge pendingMutations from storage and in memory. Has a side effect of
     * sending mutations that were stored but not acked
     */
    _onMergePendingMutations: (storageMuts: any, inMemoryMuts: any) => void;
    /**
     * On refresh we clear out pending mutations that we know have been applied
     * by the server and thus those mutations are applied in the instaql result
     * returned by the server
     */
    _cleanPendingMutations(txId: any): void;
    _flushEnqueuedRoomData(roomId: any): void;
    _handleReceive(msg: any): void;
    _sessionId: any;
    /**
     * @param {'timeout' | 'error'} status
     * @param {string} eventId
     * @param {{message?: string, hint?: string, error?: Error}} errDetails
     */
    _handleMutationError(status: "timeout" | "error", eventId: string, errDetails: {
        message?: string;
        hint?: string;
        error?: Error;
    }): void;
    _handleReceiveError(msg: any): void;
    notifyQueryOnceError(hash: any, eventId: any, e: any): void;
    _setAttrs(attrs: any): void;
    getPreviousResult: (q: any) => any;
    _startQuerySub(q: any, hash: any): string;
    /**
     *  When a user subscribes to a query the following side effects occur:
     *
     *  - We update querySubs to include the new query
     *  - We update queryCbs to include the new cb
     *  - If we already have a result for the query we call cb immediately
     *  - We send the server an `add-query` message
     *
     *  Returns an unsubscribe function
     */
    subscribeQuery(q: any, cb: any): () => void;
    queryOnce(q: any): Promise<any>;
    _completeQueryOnce(q: any, hash: any, dfd: any): void;
    _unsubQuery(q: any, hash: any, cb: any): void;
    _cleanupQuery(q: any, hash: any): void;
    _rewriteMutations(attrs: any, muts: any): any;
    optimisticAttrs(): any;
    /** Runs instaql on a query and a store */
    dataForQuery(hash: any): any;
    /** Re-run instaql and call all callbacks with new data */
    notifyOne: (hash: any) => void;
    notifyOneQueryOnce: (hash: any) => void;
    notifyQueryError: (hash: any, error: any) => void;
    /** Re-compute all subscriptions */
    notifyAll(): void;
    loadedNotifyAll(): void;
    /** Applies transactions locally and sends transact message to server */
    pushTx: (chunks: any) => Promise<any>;
    /**
     * @param {*} txSteps
     * @param {*} [error]
     * @returns
     */
    pushOps: (txSteps: any, error?: any) => Promise<any>;
    shutdown(): void;
    /**
     * Sends mutation to server and schedules a timeout to cancel it if
     * we don't hear back in time.
     * Note: If we're offline we don't schedule a timeout, we'll schedule it
     * later once we're back online and send the mutation again
     *
     */
    _sendMutation(eventId: any, mutation: any): void;
    /** Send messages we accumulated while we were connecting */
    _flushPendingMessages(): void;
    _trySendAuthed(eventId: any, msg: any): void;
    _trySend(eventId: any, msg: any): void;
    _wsOnOpen: () => void;
    _wsOnMessage: (e: any) => void;
    _wsOnError: (e: any) => void;
    _wsOnClose: () => void;
    _isManualClose: boolean;
    _ensurePreviousSocketClosed(): void;
    _startSocket(): void;
    /**
     * Given a key, returns a stable local id, unique to this device and app.
     *
     * This can be useful if you want to create guest ids for example.
     *
     * Note: If the user deletes their local storage, this id will change.
     *
     * We use this._localIdPromises to ensure that we only generate a local
     * id once, even if multiple callers call this function concurrently.
     */
    getLocalId(name: any): Promise<any>;
    _replaceUrlAfterOAuth(): void;
    /**
     *
     * @returns Promise<null | {error: {message: string}}>
     */
    _oauthLoginInit(): Promise<{
        error: {
            message: any;
        };
    }>;
    _waitForOAuthCallbackResponse(): Promise<{
        error: {
            message: string;
        };
    }>;
    __subscribeMutationErrors(cb: any): () => void;
    subscribeAuth(cb: any): () => void;
    subscribeAttrs(cb: any): () => void;
    notifyAuthSubs(user: any): void;
    notifyMutationErrorSubs(error: any): void;
    notifyAttrsSubs(): void;
    setCurrentUser(user: any): Promise<void>;
    getCurrentUserCached(): {
        isLoading: boolean;
        error: any;
        user: any;
    };
    getCurrentUser(): Promise<{
        user: any;
        error: any;
    }>;
    _hasCurrentUser(): Promise<boolean>;
    changeCurrentUser(newUser: any): Promise<void>;
    updateUser(newUser: any): void;
    sendMagicCode({ email }: {
        email: any;
    }): Promise<any>;
    signInWithMagicCode({ email, code }: {
        email: any;
        code: any;
    }): Promise<any>;
    signInWithCustomToken(authToken: any): Promise<void>;
    signOut(): Promise<void>;
    /**
     * Creates an OAuth authorization URL.
     * @param {Object} params - The parameters to create the authorization URL.
     * @param {string} params.clientName - The name of the client requesting authorization.
     * @param {string} params.redirectURL - The URL to redirect users to after authorization.
     * @returns {string} The created authorization URL.
     */
    createAuthorizationURL({ clientName, redirectURL }: {
        clientName: string;
        redirectURL: string;
    }): string;
    exchangeCodeForToken({ code, codeVerifier }: {
        code: any;
        codeVerifier: any;
    }): Promise<any>;
    issuerURI(): string;
    /**
     * @param {Object} params
     * @param {string} params.clientName - The name of the client requesting authorization.
     * @param {string} params.idToken - The id_token from the external service
     * @param {string | null | undefined} [params.nonce] - The nonce used when requesting the id_token from the external service
     */
    signInWithIdToken({ idToken, clientName, nonce }: {
        clientName: string;
        idToken: string;
        nonce?: string | null | undefined;
    }): Promise<any>;
    joinRoom(roomId: any): () => void;
    _cleanupRoom(roomId: any): void;
    /**
     * @template {keyof RoomSchema} RoomType
     * @template {keyof RoomSchema[RoomType]['presence']} Keys
     * @param {RoomType} roomType
     * @param {string | number} roomId
     * @param {import('./presence').PresenceOpts<RoomSchema[RoomType]['presence'], Keys>} opts
     * @returns {import('./presence').PresenceResponse<RoomSchema[RoomType]['presence'], Keys>}
     */
    getPresence<RoomType extends keyof RoomSchema, Keys extends keyof RoomSchema[RoomType]["presence"]>(roomType: RoomType, roomId: string | number, opts?: import("./presence").PresenceOpts<RoomSchema[RoomType]["presence"], Keys>): import("./presence").PresenceResponse<RoomSchema[RoomType]["presence"], Keys>;
    /**
     * @template {keyof RoomSchema} RoomType
     * @param {RoomType} roomType
     * @param {string | number} roomId
     * @param {Partial<RoomSchema[RoomType]['presence']>} partialData
     */
    publishPresence<RoomType extends keyof RoomSchema>(roomType: RoomType, roomId: string | number, partialData: Partial<RoomSchema[RoomType]["presence"]>): void;
    _trySetPresence(roomId: any, data: any): void;
    _tryJoinRoom(roomId: any): void;
    _tryLeaveRoom(roomId: any): void;
    /**
     * @template {keyof RoomSchema} RoomType
     * @template {keyof RoomSchema[RoomType]['presence']} Keys
     * @param {RoomType} roomType
     * @param {string | number} roomId
     * @param {import('./presence').PresenceOpts<RoomSchema[RoomType]['presence'], Keys>} opts
     * @param {(slice: import('./presence').PresenceResponse<RoomSchema[RoomType]['presence'], Keys>) => void} cb
     * @returns {() => void}
     */
    subscribePresence<RoomType extends keyof RoomSchema, Keys extends keyof RoomSchema[RoomType]["presence"]>(roomType: RoomType, roomId: string | number, opts: import("./presence").PresenceOpts<RoomSchema[RoomType]["presence"], Keys>, cb: (slice: import("./presence").PresenceResponse<RoomSchema[RoomType]["presence"], Keys>) => void): () => void;
    _notifyPresenceSubs(roomId: any): void;
    _notifyPresenceSub(roomId: any, handler: any): void;
    _setPresencePeers(roomId: any, data: any): void;
    publishTopic({ roomType, roomId, topic, data }: {
        roomType: any;
        roomId: any;
        topic: any;
        data: any;
    }): void;
    _tryBroadcast(roomId: any, roomType: any, topic: any, data: any): void;
    subscribeTopic(roomId: any, topic: any, cb: any): () => void;
    _notifyBroadcastSubs(room: any, topic: any, msg: any): void;
    upload(path: any, file: any): Promise<boolean>;
    getDownloadUrl(path: any): Promise<any>;
    deleteFile(path: any): Promise<any>;
}
import { PersistedObject } from "./utils/PersistedObject";
import { Deferred } from "./utils/Deferred";
import IndexedDBStorage from "./IndexedDBStorage";
import WindowNetworkListener from "./WindowNetworkListener";
//# sourceMappingURL=Reactor.d.ts.map