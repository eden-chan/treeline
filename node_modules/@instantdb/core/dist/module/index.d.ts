import Reactor from "./Reactor";
import { tx, txInit, lookup, getOps, type TxChunk, type TransactionChunk } from "./instatx";
import weakHash from "./utils/weakHash";
import id from "./utils/uuid";
import IndexedDBStorage from "./IndexedDBStorage";
import WindowNetworkListener from "./WindowNetworkListener";
import { i } from "./schema";
import type { PresenceOpts, PresenceResponse, PresenceSlice, RoomSchemaShape } from "./presence";
import type { IDatabase } from "./coreTypes";
import type { Query, QueryResponse, PageInfoResponse, Exactly, InstantObject, InstaQLQueryParams } from "./queryTypes";
import type { AuthState, User, AuthResult } from "./clientTypes";
import type { InstantQuery, InstantQueryResult, InstantSchema, InstantEntity, InstantSchemaDatabase } from "./helperTypes";
import type { AttrsDefs, CardinalityKind, DataAttrDef, EntitiesDef, EntitiesWithLinks, EntityDef, InstantGraph, LinkAttrDef, LinkDef, LinksDef, ResolveAttrs, ValueTypes } from "./schemaTypes";
export type Config = {
    appId: string;
    websocketURI?: string;
    apiURI?: string;
    devtool?: boolean;
};
export type ConfigWithSchema<S extends InstantGraph<any, any>> = Config & {
    schema: S;
};
export type TransactionResult = {
    status: "synced" | "enqueued";
    clientId: string;
};
export type RoomHandle<PresenceShape, TopicsByKey> = {
    leaveRoom: () => void;
    publishTopic: <Key extends keyof TopicsByKey>(topic: Key, data: TopicsByKey[Key]) => void;
    subscribeTopic: <Key extends keyof TopicsByKey>(topic: Key, onEvent: (event: TopicsByKey[Key], peer: PresenceShape) => void) => () => void;
    publishPresence: (data: Partial<PresenceShape>) => void;
    getPresence: <Keys extends keyof PresenceShape>(opts: PresenceOpts<PresenceShape, Keys>) => PresenceResponse<PresenceShape, Keys>;
    subscribePresence: <Keys extends keyof PresenceShape>(opts: PresenceOpts<PresenceShape, Keys>, onChange: (slice: PresenceResponse<PresenceShape, Keys>) => void) => () => void;
};
type AuthToken = string;
type SubscriptionState<Q, Schema, WithCardinalityInference extends boolean> = {
    error: {
        message: string;
    };
    data: undefined;
    pageInfo: undefined;
} | {
    error: undefined;
    data: QueryResponse<Q, Schema, WithCardinalityInference>;
    pageInfo: PageInfoResponse<Q>;
};
type LifecycleSubscriptionState<Q, Schema, WithCardinalityInference extends boolean> = SubscriptionState<Q, Schema, WithCardinalityInference> & {
    isLoading: boolean;
};
type UnsubscribeFn = () => void;
declare function init_experimental<Schema extends InstantGraph<any, any, any>, WithCardinalityInference extends boolean = true>(config: Config & {
    schema: Schema;
    cardinalityInference?: WithCardinalityInference;
}, Storage?: any, NetworkListener?: any): InstantCore<Schema, Schema extends InstantGraph<any, infer RoomSchema, any> ? RoomSchema : never, WithCardinalityInference>;
/**
 *
 * The first step: init your application!
 *
 * Visit https://instantdb.com/dash to get your `appId` :)
 *
 * @example
 *  const db = init({ appId: "my-app-id" })
 *
 * // You can also provide a schema for type safety and editor autocomplete!
 *
 *  type Schema = {
 *    goals: {
 *      title: string
 *    }
 *  }
 *
 *  const db = init<Schema>({ appId: "my-app-id" })
 *
 */
declare function init<Schema extends {} = {}, RoomSchema extends RoomSchemaShape = {}>(config: Config, Storage?: any, NetworkListener?: any): InstantCore<Schema, RoomSchema>;
declare function _init_internal<Schema extends {} | InstantGraph<any, any, any>, RoomSchema extends RoomSchemaShape, WithCardinalityInference extends boolean = false>(config: Config, Storage?: any, NetworkListener?: any): InstantCore<Schema, RoomSchema, WithCardinalityInference>;
declare class InstantCore<Schema extends InstantGraph<any, any> | {} = {}, RoomSchema extends RoomSchemaShape = {}, WithCardinalityInference extends boolean = false> implements IDatabase<Schema, RoomSchema, WithCardinalityInference> {
    withCardinalityInference?: WithCardinalityInference;
    _reactor: Reactor<RoomSchema>;
    auth: Auth;
    storage: Storage;
    tx: TxChunk<Schema extends InstantGraph<any, any, {}> ? Schema : InstantGraph<any, any, {}>>;
    constructor(reactor: Reactor<RoomSchema>);
    /**
     * Use this to write data! You can create, update, delete, and link objects
     *
     * @see https://instantdb.com/docs/instaml
     *
     * @example
     *   // Create a new object in the `goals` namespace
     *   const goalId = id();
     *   db.transact(tx.goals[goalId].update({title: "Get fit"}))
     *
     *   // Update the title
     *   db.transact(tx.goals[goalId].update({title: "Get super fit"}))
     *
     *   // Delete it
     *   db.transact(tx.goals[goalId].delete())
     *
     *   // Or create an association:
     *   todoId = id();
     *   db.transact([
     *    tx.todos[todoId].update({ title: 'Go on a run' }),
     *    tx.goals[goalId].link({todos: todoId}),
     *  ])
     */
    transact(chunks: TransactionChunk<any, any> | TransactionChunk<any, any>[]): Promise<TransactionResult>;
    getLocalId(name: string): Promise<string>;
    /**
     * Use this to query your data!
     *
     * @see https://instantdb.com/docs/instaql
     *
     * @example
     *  // listen to all goals
     *  db.subscribeQuery({ goals: {} }, (resp) => {
     *    console.log(resp.data.goals)
     *  })
     *
     *  // goals where the title is "Get Fit"
     *  db.subscribeQuery(
     *    { goals: { $: { where: { title: "Get Fit" } } } },
     *    (resp) => {
     *      console.log(resp.data.goals)
     *    }
     *  )
     *
     *  // all goals, _alongside_ their todos
     *  db.subscribeQuery({ goals: { todos: {} } }, (resp) => {
     *    console.log(resp.data.goals)
     *  });
     */
    subscribeQuery<Q extends Schema extends InstantGraph<any, any> ? InstaQLQueryParams<Schema> : Exactly<Query, Q>>(query: Q, cb: (resp: SubscriptionState<Q, Schema, WithCardinalityInference>) => void): () => void;
    /**
     * Listen for the logged in state. This is useful
     * for deciding when to show a login screen.
     *
     * @see https://instantdb.com/docs/auth
     * @example
     *   const unsub = db.subscribeAuth((auth) => {
     *     if (auth.user) {
     *     console.log('logged in as', auth.user.email)
     *    } else {
     *      console.log('logged out')
     *    }
     *  })
     */
    subscribeAuth(cb: (auth: AuthResult) => void): UnsubscribeFn;
    /**
     * Join a room to publish and subscribe to topics and presence.
     *
     * @see https://instantdb.com/docs/presence-and-topics
     * @example
     * // init
     * const db = init();
     * const room = db.joinRoom(roomType, roomId);
     * // usage
     * const unsubscribeTopic = room.subscribeTopic("foo", console.log);
     * const unsubscribePresence = room.subscribePresence({}, console.log);
     * room.publishTopic("hello", { message: "hello world!" });
     * room.publishPresence({ name: "joe" });
     * // later
     * unsubscribePresence();
     * unsubscribeTopic();
     * room.leaveRoom();
     */
    joinRoom<RoomType extends keyof RoomSchema>(roomType?: RoomType, roomId?: string): RoomHandle<RoomSchema[RoomType]["presence"], RoomSchema[RoomType]["topics"]>;
    shutdown(): void;
    /**
     * Use this for one-off queries.
     * Returns local data if available, otherwise fetches from the server.
     * Because we want to avoid stale data, this method will throw an error
     * if the user is offline or there is no active connection to the server.
     *
     * @see https://instantdb.com/docs/instaql
     *
     * @example
     *
     *  const resp = await db.queryOnce({ goals: {} });
     *  console.log(resp.data.goals)
     */
    queryOnce<Q extends Schema extends InstantGraph<any, any> ? InstaQLQueryParams<Schema> : Exactly<Query, Q>>(query: Q): Promise<{
        data: QueryResponse<Q, Schema, WithCardinalityInference>;
        pageInfo: PageInfoResponse<Q>;
    }>;
}
/**
 * Functions to log users in and out.
 *
 * @see https://instantdb.com/docs/auth
 */
declare class Auth {
    private db;
    constructor(db: Reactor);
    /**
     * Sends a magic code to the user's email address.
     *
     * Once you send the magic code, see {@link auth.signInWithMagicCode} to let the
     * user verify.
     *
     * @see https://instantdb.com/docs/auth
     * @example
     *  db.auth.sendMagicCode({email: "example@gmail.com"})
     *    .catch((err) => console.error(err.body?.message))
     */
    sendMagicCode: (params: {
        email: string;
    }) => Promise<any>;
    /**
     * Verify a magic code that was sent to the user's email address.
     *
     * @see https://instantdb.com/docs/auth
     *
     * @example
     *  db.auth.signInWithMagicCode({email: "example@gmail.com", code: "123456"})
     *       .catch((err) => console.error(err.body?.message))
     */
    signInWithMagicCode: (params: {
        email: string;
        code: string;
    }) => Promise<any>;
    /**
     * Sign in a user with a refresh toke
     *
     * @see https://instantdb.com/docs/backend#frontend-auth-sign-in-with-token
     *
     * @example
     *   // Get the token from your backend
     *   const token = await fetch('/signin', ...);
     *   //Sign in
     *   db.auth.signInWithToken(token);
     */
    signInWithToken: (token: AuthToken) => Promise<void>;
    /**
     * Create an authorization url to sign in with an external provider
     *
     * @see https://instantdb.com/docs/auth
     *
     * @example
     *   // Get the authorization url from your backend
     *   const url = db.auth.createAuthorizationUrl({
     *     clientName: "google",
     *     redirectURL: window.location.href,
     *   });
     *
     *   // Put it in a sign in link
     *   <a href={url}>Log in with Google</a>
     */
    createAuthorizationURL: (params: {
        clientName: string;
        redirectURL: any;
    }) => string;
    /**
     * Sign in with the id_token from an external provider like Google
     *
     * @see https://instantdb.com/docs/auth
     * @example
     *   db.auth
     *  .signInWithIdToken({
     *    // Token from external service
     *    idToken: id_token,
     *    // The name you gave the client when you registered it with Instant
     *    clientName: "google",
     *    // The nonce, if any, that you used when you initiated the auth flow
     *    // with the external service.
     *    nonce: your_nonce
     *  })
     *  .catch((err) => console.error(err.body?.message));
     *
     */
    signInWithIdToken: (params: {
        idToken: string;
        clientName: string;
        nonce?: string | undefined | null;
    }) => Promise<any>;
    /**
     * Sign in with the id_token from an external provider like Google
     *
     * @see https://instantdb.com/docs/auth
     * @example
     *   db.auth
     *  .exchangeOAuthCode({
     *    // code received in redirect from OAuth callback
     *    code: code
     *    // The PKCE code_verifier, if any, that you used when you
     *    // initiated the auth flow
     *    codeVerifier: your_code_verifier
     *  })
     *  .catch((err) => console.error(err.body?.message));
     *
     */
    exchangeOAuthCode: (params: {
        code: string;
        codeVerifier: string | undefined | null;
    }) => Promise<any>;
    /**
     * OpenID Discovery path for use with tools like
     * expo-auth-session that use auto-discovery of
     * OAuth parameters.
     *
     * @see https://instantdb.com/docs/auth
     * @example
     *   const discovery = useAutoDiscovery(
     *     db.auth.issuerURI()
     *   );
     */
    issuerURI: () => string;
    /**
     * Sign out the current user
     */
    signOut: () => Promise<void>;
}
/**
 * Functions to manage file storage.
 */
declare class Storage {
    private db;
    constructor(db: Reactor);
    /**
     * Uploads file at the provided path.
     *
     * @see https://instantdb.com/docs/storage
     * @example
     *   const [file] = e.target.files; // result of file input
     *   const isSuccess = await db.storage.upload('photos/demo.png', file);
     */
    upload: (pathname: string, file: File) => Promise<boolean>;
    /**
     * @deprecated Use `db.storage.upload` instead
     */
    put: (pathname: string, file: File) => Promise<boolean>;
    /**
     * Retrieves a download URL for the provided path.
     *
     * @see https://instantdb.com/docs/storage
     * @example
     *   const url = await db.storage.getDownloadUrl('photos/demo.png');
     */
    getDownloadUrl: (pathname: string) => Promise<any>;
    /**
     * Deletes a file by path name.
     *
     * @see https://instantdb.com/docs/storage
     * @example
     *   await db.storage.delete('photos/demo.png');
     */
    delete: (pathname: string) => Promise<any>;
}
declare function coerceQuery(o: any): any;
export { init, init_experimental, _init_internal, id, tx, txInit, lookup, i, getOps, coerceQuery, weakHash, IndexedDBStorage, WindowNetworkListener, InstantCore as InstantClient, Auth, Storage, type IDatabase, type RoomSchemaShape, type Query, type QueryResponse, type PageInfoResponse, type InstantObject, type Exactly, type TransactionChunk, type AuthState, type User, type AuthToken, type TxChunk, type SubscriptionState, type LifecycleSubscriptionState, type PresenceOpts, type PresenceSlice, type PresenceResponse, type InstaQLQueryParams, type InstantQuery, type InstantQueryResult, type InstantSchema, type InstantEntity, type InstantSchemaDatabase, type AttrsDefs, type CardinalityKind, type DataAttrDef, type EntitiesDef, type EntitiesWithLinks, type EntityDef, type InstantGraph, type LinkAttrDef, type LinkDef, type LinksDef, type ResolveAttrs, type ValueTypes, };
//# sourceMappingURL=index.d.ts.map