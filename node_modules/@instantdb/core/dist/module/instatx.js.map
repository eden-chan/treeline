{"version":3,"file":"instatx.js","sourceRoot":"","sources":["../../src/instatx.ts"],"names":[],"mappings":"AA2IA,SAAS,gBAAgB,CACvB,KAAY,EACZ,EAAkB,EAClB,OAAa;IAEb,OAAO,IAAI,KAAK,CAAC,EAAgC,EAAE;QACjD,GAAG,EAAE,CAAC,OAAO,EAAE,GAAqC,EAAE,EAAE;YACtD,IAAI,GAAG,KAAK,OAAO;gBAAE,OAAO,OAAO,CAAC;YACpC,OAAO,CAAC,IAAU,EAAE,EAAE;gBACpB,OAAO,gBAAgB,CAAC,KAAK,EAAE,EAAE,EAAE;oBACjC,GAAG,OAAO;oBACV,CAAC,GAAG,EAAE,KAAK,EAAE,EAAE,EAAE,IAAI,CAAC;iBACvB,CAAC,CAAC;YACL,CAAC,CAAC;QACJ,CAAC;KACF,CAAC,CAAC;AACL,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,MAAM,CAAC,SAAiB,EAAE,KAAU;IAClD,OAAO,WAAW,SAAS,KAAK,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,EAAE,CAAC;AAC1D,CAAC;AAED,MAAM,UAAU,QAAQ,CAAC,CAAS;IAChC,OAAO,CAAC,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC;AAClC,CAAC;AAED,MAAM,UAAU,WAAW,CAAC,CAAS;IACnC,MAAM,CAAC,CAAC,EAAE,SAAS,EAAE,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;IAC/C,OAAO,CAAC,SAAS,EAAE,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AACnD,CAAC;AAED,SAAS,UAAU,CAAC,KAAY;IAC9B,OAAO,IAAI,KAAK,CACd,EAAE,EACF;QACE,GAAG,CAAC,OAAO,EAAE,EAAM;YACjB,IAAI,QAAQ,CAAC,EAAE,CAAC,EAAE,CAAC;gBACjB,OAAO,gBAAgB,CAAC,KAAK,EAAE,WAAW,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC;YACtD,CAAC;YACD,OAAO,gBAAgB,CAAC,KAAK,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC;QACzC,CAAC;KACF,CACF,CAAC;AACJ,CAAC;AAED,MAAM,UAAU,MAAM;IAGpB,OAAO,IAAI,KAAK,CACd,EAAE,EACF;QACE,GAAG,CAAC,OAAO,EAAE,EAAS;YACpB,OAAO,UAAU,CAAC,EAAE,CAAC,CAAC;QACxB,CAAC;KACF,CACK,CAAC;AACX,CAAC;AAED;;;;;;;;GAQG;AACH,MAAM,CAAC,MAAM,EAAE,GAAG,MAAM,EAAE,CAAC;AAE3B,MAAM,UAAU,MAAM,CAAC,CAA6B;IAClD,OAAO,CAAC,CAAC,KAAK,CAAC;AACjB,CAAC","sourcesContent":["import type { DataAttrDef, InstantGraph, LinkAttrDef } from \"./schemaTypes\";\n\ntype Action = \"update\" | \"link\" | \"unlink\" | \"delete\" | \"merge\";\ntype EType = string;\ntype Id = string;\ntype Args = any;\ntype LookupRef = [string, any];\ntype Lookup = string;\nexport type Op = [Action, EType, Id | LookupRef, Args];\n\ntype UpdateParams<\n  Schema extends InstantGraph<any, any>,\n  EntityName extends keyof Schema[\"entities\"],\n> = {\n  [AttrName in keyof Schema[\"entities\"][EntityName][\"attrs\"]]?: Schema[\"entities\"][EntityName][\"attrs\"][AttrName] extends DataAttrDef<\n    infer ValueType,\n    infer IsRequired\n  >\n    ? IsRequired extends true\n      ? ValueType\n      : ValueType | null\n    : never;\n} & (Schema extends InstantGraph<any, any>\n  ? {}\n  : {\n      [attribute: string]: any;\n    });\n\ntype LinkParams<\n  Schema extends InstantGraph<any, any>,\n  EntityName extends keyof Schema[\"entities\"],\n> = {\n  [LinkName in keyof Schema[\"entities\"][EntityName][\"links\"]]?: Schema[\"entities\"][EntityName][\"links\"][LinkName] extends LinkAttrDef<\n    infer Cardinality,\n    any\n  >\n    ? Cardinality extends \"one\"\n      ? string\n      : string | string[]\n    : never;\n} & (Schema extends InstantGraph<any, any> ? {} : { [attribute: string]: any });\n\nexport interface TransactionChunk<\n  Schema extends InstantGraph<any, any, any>,\n  EntityName extends keyof Schema[\"entities\"],\n> {\n  __ops: Op[];\n  /**\n   * Create and update objects:\n   *\n   * @example\n   *  const goalId = id();\n   *  tx.goals[goalId].update({title: \"Get fit\", difficulty: 5})\n   */\n  update: (\n    args: UpdateParams<Schema, EntityName>,\n  ) => TransactionChunk<Schema, EntityName>;\n  /**\n   * Link two objects together\n   *\n   * @example\n   * const goalId = id();\n   * const todoId = id();\n   * db.transact([\n   *   tx.goals[goalId].update({title: \"Get fit\"}),\n   *   tx.todos[todoId].update({title: \"Go on a run\"}),\n   *   tx.goals[goalId].link({todos: todoId}),\n   * ])\n   *\n   * // Now, if you query:\n   * useQuery({ goals: { todos: {} } })\n   * // You'll get back:\n   *\n   * // { goals: [{ title: \"Get fit\", todos: [{ title: \"Go on a run\" }]}\n   */\n  link: (\n    args: LinkParams<Schema, EntityName>,\n  ) => TransactionChunk<Schema, EntityName>;\n  /**\n   * Unlink two objects\n   * @example\n   *  // to \"unlink\" a todo from a goal:\n   *  tx.goals[goalId].unlink({todos: todoId})\n   */\n  unlink: (\n    args: LinkParams<Schema, EntityName>,\n  ) => TransactionChunk<Schema, EntityName>;\n  /**\n   * Delete an object, alongside all of its links.\n   *\n   * @example\n   *   tx.goals[goalId].delete()\n   */\n  delete: () => TransactionChunk<Schema, EntityName>;\n\n  /**\n   *\n   * Similar to `update`, but instead of overwriting the current value, it will merge the provided values into the current value.\n   *\n   * This is useful for deeply nested, document-style values, or for updating a single attribute at an arbitrary depth without overwriting the rest of the object.\n   *\n   * For example, if you have a goal with a nested `metrics` object:\n   *\n   * ```js\n   * goal = { name: \"Get fit\", metrics: { progress: 0.3 } }\n   * ```\n   *\n   * You can update the `progress` attribute like so:\n   *\n   * ```js\n   * tx.goals[goalId].merge({ metrics: { progress: 0.5 }, category: \"Fitness\" })\n   * ```\n   *\n   * And the resulting object will be:\n   *\n   * ```js\n   * goal = { name: \"Get fit\", metrics: { progress: 0.5 }, category: \"Fitness\"  }\n   *  ```\n   *\n   * @example\n   *  const goalId = id();\n   *  tx.goals[goalId].merge({title: \"Get fitter\"})\n   */\n  merge: (args: {\n    [attribute: string]: any;\n  }) => TransactionChunk<Schema, EntityName>;\n}\n\nexport interface ETypeChunk<\n  Schema extends InstantGraph<any, any>,\n  EntityName extends keyof Schema[\"entities\"],\n> {\n  [id: Id]: TransactionChunk<Schema, EntityName>;\n}\n\nexport type TxChunk<Schema extends InstantGraph<any, any>> = {\n  [EntityName in keyof Schema[\"entities\"]]: ETypeChunk<Schema, EntityName>;\n};\n\nfunction transactionChunk(\n  etype: EType,\n  id: Id | LookupRef,\n  prevOps: Op[],\n): TransactionChunk<any, any> {\n  return new Proxy({} as TransactionChunk<any, any>, {\n    get: (_target, cmd: keyof TransactionChunk<any, any>) => {\n      if (cmd === \"__ops\") return prevOps;\n      return (args: Args) => {\n        return transactionChunk(etype, id, [\n          ...prevOps,\n          [cmd, etype, id, args],\n        ]);\n      };\n    },\n  });\n}\n\n/**\n * Creates a lookup to use in place of an id in a transaction\n *\n * @example\n * tx.users[lookup('email', 'lyndon@example.com')].update({name: 'Lyndon'})\n */\nexport function lookup(attribute: string, value: any): Lookup {\n  return `lookup__${attribute}__${JSON.stringify(value)}`;\n}\n\nexport function isLookup(k: string): boolean {\n  return k.startsWith(\"lookup__\");\n}\n\nexport function parseLookup(k: string): LookupRef {\n  const [_, attribute, ...vJSON] = k.split(\"__\");\n  return [attribute, JSON.parse(vJSON.join(\"__\"))];\n}\n\nfunction etypeChunk(etype: EType): ETypeChunk<any, EType> {\n  return new Proxy(\n    {},\n    {\n      get(_target, id: Id) {\n        if (isLookup(id)) {\n          return transactionChunk(etype, parseLookup(id), []);\n        }\n        return transactionChunk(etype, id, []);\n      },\n    },\n  );\n}\n\nexport function txInit<\n  Schema extends InstantGraph<any, any>,\n>(): TxChunk<Schema> {\n  return new Proxy(\n    {},\n    {\n      get(_target, ns: EType) {\n        return etypeChunk(ns);\n      },\n    },\n  ) as any;\n}\n\n/**\n * A handy builder for changes.\n *\n * You must start with the `namespace` you want to change:\n *\n * @example\n *   tx.goals[goalId].update({title: \"Get fit\"})\n *   // Note: you don't need to create `goals` ahead of time.\n */\nexport const tx = txInit();\n\nexport function getOps(x: TransactionChunk<any, any>): Op[] {\n  return x.__ops;\n}\n"]}