"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.i = void 0;
const schemaTypes_1 = require("./schemaTypes");
// ==========
// API
/**
 * Accepts entities and links and merges them into a single graph definition.
 *
 * @see https://instantdb.com/docs/schema#defining-entities
 * @example
 *   export default i.graph(
 *     {
 *       posts: i.entity({
 *         title: i.string(),
 *         body: i.string(),
 *       }),
 *       comments: i.entity({
 *         body: i.string(),
 *       }),
 *     },
 *     {
 *       postsComments: {
 *         forward: {
 *           on: "posts",
 *           has: "many",
 *           label: "comments",
 *         },
 *         reverse: {
 *           on: "comments",
 *           has: "one",
 *           label: "post",
 *         },
 *       },
 *     },
 *   );
 */
function graph(entities, links) {
    return new schemaTypes_1.InstantGraph(enrichEntitiesWithLinks(entities, links), 
    // (XXX): LinksDef<any> stems from TypeScriptâ€™s inability to reconcile the
    // type EntitiesWithLinks<EntitiesWithoutLinks, Links> with
    // EntitiesWithoutLinks. TypeScript is strict about ensuring that types are
    // correctly aligned and does not allow for substituting a type that might
    // be broader or have additional properties.
    links);
}
/**
 * Creates an entity definition, to be used in conjunction with `i.graph`.
 *
 * @see https://instantdb.com/docs/schema
 * @example
 *   {
 *     posts: i.entity({
 *       title: i.string(),
 *       body: i.string(),
 *     }),
 *     comments: i.entity({
 *       body: i.string(),
 *     })
 *   }
 */
function entity(attrs) {
    return new schemaTypes_1.EntityDef(attrs, {});
}
function string() {
    return new schemaTypes_1.DataAttrDef("string", true);
}
function number() {
    return new schemaTypes_1.DataAttrDef("number", true);
}
function boolean() {
    return new schemaTypes_1.DataAttrDef("boolean", true);
}
function json() {
    return new schemaTypes_1.DataAttrDef("json", true);
}
function any() {
    return new schemaTypes_1.DataAttrDef("json", true);
}
// ==========
// internal
function enrichEntitiesWithLinks(entities, links) {
    var _a, _b, _c, _d;
    const linksIndex = { fwd: {}, rev: {} };
    for (const linkDef of Object.values(links)) {
        (_a = linksIndex.fwd)[_b = linkDef.forward.on] || (_a[_b] = {});
        (_c = linksIndex.rev)[_d = linkDef.reverse.on] || (_c[_d] = {});
        linksIndex.fwd[linkDef.forward.on][linkDef.forward.label] = {
            entityName: linkDef.reverse.on,
            cardinality: linkDef.forward.has,
        };
        linksIndex.rev[linkDef.reverse.on][linkDef.reverse.label] = {
            entityName: linkDef.forward.on,
            cardinality: linkDef.reverse.has,
        };
    }
    const enrichedEntities = Object.fromEntries(Object.entries(entities).map(([name, def]) => [
        name,
        new schemaTypes_1.EntityDef(def.attrs, Object.assign(Object.assign({}, linksIndex.fwd[name]), linksIndex.rev[name])),
    ]));
    return enrichedEntities;
}
exports.i = {
    // constructs
    graph,
    entity,
    // value types
    string,
    number,
    boolean,
    json,
    any,
};
//# sourceMappingURL=schema.js.map