import {
  require_jsx_runtime
} from "./chunk-KZJXRDQX.js";
import {
  require_react
} from "./chunk-3ZBYBBZQ.js";
import {
  __commonJS,
  __require,
  __toESM
} from "./chunk-OL46QLBJ.js";

// ../node_modules/object-hash/dist/object_hash.js
var require_object_hash = __commonJS({
  "../node_modules/object-hash/dist/object_hash.js"(exports, module) {
    !function(e) {
      var t;
      "object" == typeof exports ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : ("undefined" != typeof window ? t = window : "undefined" != typeof global ? t = global : "undefined" != typeof self && (t = self), t.objectHash = e());
    }(function() {
      return function r(o, i2, u) {
        function s(n, e2) {
          if (!i2[n]) {
            if (!o[n]) {
              var t = "function" == typeof __require && __require;
              if (!e2 && t) return t(n, true);
              if (a) return a(n, true);
              throw new Error("Cannot find module '" + n + "'");
            }
            e2 = i2[n] = { exports: {} };
            o[n][0].call(e2.exports, function(e3) {
              var t2 = o[n][1][e3];
              return s(t2 || e3);
            }, e2, e2.exports, r, o, i2, u);
          }
          return i2[n].exports;
        }
        for (var a = "function" == typeof __require && __require, e = 0; e < u.length; e++) s(u[e]);
        return s;
      }({ 1: [function(w, b, m) {
        !(function(e, n, s, c, d, h, p, g, y) {
          "use strict";
          var r = w("crypto");
          function t(e2, t2) {
            t2 = u(e2, t2);
            var n2;
            return void 0 === (n2 = "passthrough" !== t2.algorithm ? r.createHash(t2.algorithm) : new l()).write && (n2.write = n2.update, n2.end = n2.update), f2(t2, n2).dispatch(e2), n2.update || n2.end(""), n2.digest ? n2.digest("buffer" === t2.encoding ? void 0 : t2.encoding) : (e2 = n2.read(), "buffer" !== t2.encoding ? e2.toString(t2.encoding) : e2);
          }
          (m = b.exports = t).sha1 = function(e2) {
            return t(e2);
          }, m.keys = function(e2) {
            return t(e2, { excludeValues: true, algorithm: "sha1", encoding: "hex" });
          }, m.MD5 = function(e2) {
            return t(e2, { algorithm: "md5", encoding: "hex" });
          }, m.keysMD5 = function(e2) {
            return t(e2, { algorithm: "md5", encoding: "hex", excludeValues: true });
          };
          var o = r.getHashes ? r.getHashes().slice() : ["sha1", "md5"], i2 = (o.push("passthrough"), ["buffer", "hex", "binary", "base64"]);
          function u(e2, t2) {
            var n2 = {};
            if (n2.algorithm = (t2 = t2 || {}).algorithm || "sha1", n2.encoding = t2.encoding || "hex", n2.excludeValues = !!t2.excludeValues, n2.algorithm = n2.algorithm.toLowerCase(), n2.encoding = n2.encoding.toLowerCase(), n2.ignoreUnknown = true === t2.ignoreUnknown, n2.respectType = false !== t2.respectType, n2.respectFunctionNames = false !== t2.respectFunctionNames, n2.respectFunctionProperties = false !== t2.respectFunctionProperties, n2.unorderedArrays = true === t2.unorderedArrays, n2.unorderedSets = false !== t2.unorderedSets, n2.unorderedObjects = false !== t2.unorderedObjects, n2.replacer = t2.replacer || void 0, n2.excludeKeys = t2.excludeKeys || void 0, void 0 === e2) throw new Error("Object argument required.");
            for (var r2 = 0; r2 < o.length; ++r2) o[r2].toLowerCase() === n2.algorithm.toLowerCase() && (n2.algorithm = o[r2]);
            if (-1 === o.indexOf(n2.algorithm)) throw new Error('Algorithm "' + n2.algorithm + '"  not supported. supported values: ' + o.join(", "));
            if (-1 === i2.indexOf(n2.encoding) && "passthrough" !== n2.algorithm) throw new Error('Encoding "' + n2.encoding + '"  not supported. supported values: ' + i2.join(", "));
            return n2;
          }
          function a(e2) {
            if ("function" == typeof e2) return null != /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(e2));
          }
          function f2(o2, t2, i3) {
            i3 = i3 || [];
            function u2(e2) {
              return t2.update ? t2.update(e2, "utf8") : t2.write(e2, "utf8");
            }
            return { dispatch: function(e2) {
              return this["_" + (null === (e2 = o2.replacer ? o2.replacer(e2) : e2) ? "null" : typeof e2)](e2);
            }, _object: function(t3) {
              var n2, e2 = Object.prototype.toString.call(t3), r2 = /\[object (.*)\]/i.exec(e2);
              r2 = (r2 = r2 ? r2[1] : "unknown:[" + e2 + "]").toLowerCase();
              if (0 <= (e2 = i3.indexOf(t3))) return this.dispatch("[CIRCULAR:" + e2 + "]");
              if (i3.push(t3), void 0 !== s && s.isBuffer && s.isBuffer(t3)) return u2("buffer:"), u2(t3);
              if ("object" === r2 || "function" === r2 || "asyncfunction" === r2) return e2 = Object.keys(t3), o2.unorderedObjects && (e2 = e2.sort()), false === o2.respectType || a(t3) || e2.splice(0, 0, "prototype", "__proto__", "constructor"), o2.excludeKeys && (e2 = e2.filter(function(e3) {
                return !o2.excludeKeys(e3);
              })), u2("object:" + e2.length + ":"), n2 = this, e2.forEach(function(e3) {
                n2.dispatch(e3), u2(":"), o2.excludeValues || n2.dispatch(t3[e3]), u2(",");
              });
              if (!this["_" + r2]) {
                if (o2.ignoreUnknown) return u2("[" + r2 + "]");
                throw new Error('Unknown object type "' + r2 + '"');
              }
              this["_" + r2](t3);
            }, _array: function(e2, t3) {
              t3 = void 0 !== t3 ? t3 : false !== o2.unorderedArrays;
              var n2 = this;
              if (u2("array:" + e2.length + ":"), !t3 || e2.length <= 1) return e2.forEach(function(e3) {
                return n2.dispatch(e3);
              });
              var r2 = [], t3 = e2.map(function(e3) {
                var t4 = new l(), n3 = i3.slice();
                return f2(o2, t4, n3).dispatch(e3), r2 = r2.concat(n3.slice(i3.length)), t4.read().toString();
              });
              return i3 = i3.concat(r2), t3.sort(), this._array(t3, false);
            }, _date: function(e2) {
              return u2("date:" + e2.toJSON());
            }, _symbol: function(e2) {
              return u2("symbol:" + e2.toString());
            }, _error: function(e2) {
              return u2("error:" + e2.toString());
            }, _boolean: function(e2) {
              return u2("bool:" + e2.toString());
            }, _string: function(e2) {
              u2("string:" + e2.length + ":"), u2(e2.toString());
            }, _function: function(e2) {
              u2("fn:"), a(e2) ? this.dispatch("[native]") : this.dispatch(e2.toString()), false !== o2.respectFunctionNames && this.dispatch("function-name:" + String(e2.name)), o2.respectFunctionProperties && this._object(e2);
            }, _number: function(e2) {
              return u2("number:" + e2.toString());
            }, _xml: function(e2) {
              return u2("xml:" + e2.toString());
            }, _null: function() {
              return u2("Null");
            }, _undefined: function() {
              return u2("Undefined");
            }, _regexp: function(e2) {
              return u2("regex:" + e2.toString());
            }, _uint8array: function(e2) {
              return u2("uint8array:"), this.dispatch(Array.prototype.slice.call(e2));
            }, _uint8clampedarray: function(e2) {
              return u2("uint8clampedarray:"), this.dispatch(Array.prototype.slice.call(e2));
            }, _int8array: function(e2) {
              return u2("int8array:"), this.dispatch(Array.prototype.slice.call(e2));
            }, _uint16array: function(e2) {
              return u2("uint16array:"), this.dispatch(Array.prototype.slice.call(e2));
            }, _int16array: function(e2) {
              return u2("int16array:"), this.dispatch(Array.prototype.slice.call(e2));
            }, _uint32array: function(e2) {
              return u2("uint32array:"), this.dispatch(Array.prototype.slice.call(e2));
            }, _int32array: function(e2) {
              return u2("int32array:"), this.dispatch(Array.prototype.slice.call(e2));
            }, _float32array: function(e2) {
              return u2("float32array:"), this.dispatch(Array.prototype.slice.call(e2));
            }, _float64array: function(e2) {
              return u2("float64array:"), this.dispatch(Array.prototype.slice.call(e2));
            }, _arraybuffer: function(e2) {
              return u2("arraybuffer:"), this.dispatch(new Uint8Array(e2));
            }, _url: function(e2) {
              return u2("url:" + e2.toString());
            }, _map: function(e2) {
              u2("map:");
              e2 = Array.from(e2);
              return this._array(e2, false !== o2.unorderedSets);
            }, _set: function(e2) {
              u2("set:");
              e2 = Array.from(e2);
              return this._array(e2, false !== o2.unorderedSets);
            }, _file: function(e2) {
              return u2("file:"), this.dispatch([e2.name, e2.size, e2.type, e2.lastModfied]);
            }, _blob: function() {
              if (o2.ignoreUnknown) return u2("[blob]");
              throw Error('Hashing Blob objects is currently not supported\n(see https://github.com/puleos/object-hash/issues/26)\nUse "options.replacer" or "options.ignoreUnknown"\n');
            }, _domwindow: function() {
              return u2("domwindow");
            }, _bigint: function(e2) {
              return u2("bigint:" + e2.toString());
            }, _process: function() {
              return u2("process");
            }, _timer: function() {
              return u2("timer");
            }, _pipe: function() {
              return u2("pipe");
            }, _tcp: function() {
              return u2("tcp");
            }, _udp: function() {
              return u2("udp");
            }, _tty: function() {
              return u2("tty");
            }, _statwatcher: function() {
              return u2("statwatcher");
            }, _securecontext: function() {
              return u2("securecontext");
            }, _connection: function() {
              return u2("connection");
            }, _zlib: function() {
              return u2("zlib");
            }, _context: function() {
              return u2("context");
            }, _nodescript: function() {
              return u2("nodescript");
            }, _httpparser: function() {
              return u2("httpparser");
            }, _dataview: function() {
              return u2("dataview");
            }, _signal: function() {
              return u2("signal");
            }, _fsevent: function() {
              return u2("fsevent");
            }, _tlswrap: function() {
              return u2("tlswrap");
            } };
          }
          function l() {
            return { buf: "", write: function(e2) {
              this.buf += e2;
            }, end: function(e2) {
              this.buf += e2;
            }, read: function() {
              return this.buf;
            } };
          }
          m.writeToStream = function(e2, t2, n2) {
            return void 0 === n2 && (n2 = t2, t2 = {}), f2(t2 = u(e2, t2), n2).dispatch(e2);
          };
        }).call(this, w("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, w("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/fake_9a5aa49d.js", "/");
      }, { buffer: 3, crypto: 5, lYpoI2: 11 }], 2: [function(e, t, f2) {
        !(function(e2, t2, n, r, o, i2, u, s, a) {
          !function(e3) {
            "use strict";
            var a2 = "undefined" != typeof Uint8Array ? Uint8Array : Array, t3 = "+".charCodeAt(0), n2 = "/".charCodeAt(0), r2 = "0".charCodeAt(0), o2 = "a".charCodeAt(0), i3 = "A".charCodeAt(0), u2 = "-".charCodeAt(0), s2 = "_".charCodeAt(0);
            function f3(e4) {
              e4 = e4.charCodeAt(0);
              return e4 === t3 || e4 === u2 ? 62 : e4 === n2 || e4 === s2 ? 63 : e4 < r2 ? -1 : e4 < r2 + 10 ? e4 - r2 + 26 + 26 : e4 < i3 + 26 ? e4 - i3 : e4 < o2 + 26 ? e4 - o2 + 26 : void 0;
            }
            e3.toByteArray = function(e4) {
              var t4, n3;
              if (0 < e4.length % 4) throw new Error("Invalid string. Length must be a multiple of 4");
              var r3 = e4.length, r3 = "=" === e4.charAt(r3 - 2) ? 2 : "=" === e4.charAt(r3 - 1) ? 1 : 0, o3 = new a2(3 * e4.length / 4 - r3), i4 = 0 < r3 ? e4.length - 4 : e4.length, u3 = 0;
              function s3(e5) {
                o3[u3++] = e5;
              }
              for (t4 = 0; t4 < i4; t4 += 4, 0) s3((16711680 & (n3 = f3(e4.charAt(t4)) << 18 | f3(e4.charAt(t4 + 1)) << 12 | f3(e4.charAt(t4 + 2)) << 6 | f3(e4.charAt(t4 + 3)))) >> 16), s3((65280 & n3) >> 8), s3(255 & n3);
              return 2 == r3 ? s3(255 & (n3 = f3(e4.charAt(t4)) << 2 | f3(e4.charAt(t4 + 1)) >> 4)) : 1 == r3 && (s3((n3 = f3(e4.charAt(t4)) << 10 | f3(e4.charAt(t4 + 1)) << 4 | f3(e4.charAt(t4 + 2)) >> 2) >> 8 & 255), s3(255 & n3)), o3;
            }, e3.fromByteArray = function(e4) {
              var t4, n3, r3, o3, i4 = e4.length % 3, u3 = "";
              function s3(e5) {
                return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(e5);
              }
              for (t4 = 0, r3 = e4.length - i4; t4 < r3; t4 += 3) n3 = (e4[t4] << 16) + (e4[t4 + 1] << 8) + e4[t4 + 2], u3 += s3((o3 = n3) >> 18 & 63) + s3(o3 >> 12 & 63) + s3(o3 >> 6 & 63) + s3(63 & o3);
              switch (i4) {
                case 1:
                  u3 = (u3 += s3((n3 = e4[e4.length - 1]) >> 2)) + s3(n3 << 4 & 63) + "==";
                  break;
                case 2:
                  u3 = (u3 = (u3 += s3((n3 = (e4[e4.length - 2] << 8) + e4[e4.length - 1]) >> 10)) + s3(n3 >> 4 & 63)) + s3(n3 << 2 & 63) + "=";
              }
              return u3;
            };
          }(void 0 === f2 ? this.base64js = {} : f2);
        }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js", "/node_modules/gulp-browserify/node_modules/base64-js/lib");
      }, { buffer: 3, lYpoI2: 11 }], 3: [function(O, e, H) {
        !(function(e2, n, f2, r, h, p, g, y, w) {
          var a = O("base64-js"), i2 = O("ieee754");
          function f2(e3, t2, n2) {
            if (!(this instanceof f2)) return new f2(e3, t2, n2);
            var r2, o2, i3, u2, s2 = typeof e3;
            if ("base64" === t2 && "string" == s2) for (e3 = (u2 = e3).trim ? u2.trim() : u2.replace(/^\s+|\s+$/g, ""); e3.length % 4 != 0; ) e3 += "=";
            if ("number" == s2) r2 = j(e3);
            else if ("string" == s2) r2 = f2.byteLength(e3, t2);
            else {
              if ("object" != s2) throw new Error("First argument needs to be a number, array or string.");
              r2 = j(e3.length);
            }
            if (f2._useTypedArrays ? o2 = f2._augment(new Uint8Array(r2)) : ((o2 = this).length = r2, o2._isBuffer = true), f2._useTypedArrays && "number" == typeof e3.byteLength) o2._set(e3);
            else if (C(u2 = e3) || f2.isBuffer(u2) || u2 && "object" == typeof u2 && "number" == typeof u2.length) for (i3 = 0; i3 < r2; i3++) f2.isBuffer(e3) ? o2[i3] = e3.readUInt8(i3) : o2[i3] = e3[i3];
            else if ("string" == s2) o2.write(e3, 0, t2);
            else if ("number" == s2 && !f2._useTypedArrays && !n2) for (i3 = 0; i3 < r2; i3++) o2[i3] = 0;
            return o2;
          }
          function b(e3, t2, n2, r2) {
            return f2._charsWritten = c(function(e4) {
              for (var t3 = [], n3 = 0; n3 < e4.length; n3++) t3.push(255 & e4.charCodeAt(n3));
              return t3;
            }(t2), e3, n2, r2);
          }
          function m(e3, t2, n2, r2) {
            return f2._charsWritten = c(function(e4) {
              for (var t3, n3, r3 = [], o2 = 0; o2 < e4.length; o2++) n3 = e4.charCodeAt(o2), t3 = n3 >> 8, n3 = n3 % 256, r3.push(n3), r3.push(t3);
              return r3;
            }(t2), e3, n2, r2);
          }
          function v(e3, t2, n2) {
            var r2 = "";
            n2 = Math.min(e3.length, n2);
            for (var o2 = t2; o2 < n2; o2++) r2 += String.fromCharCode(e3[o2]);
            return r2;
          }
          function o(e3, t2, n2, r2) {
            r2 || (d("boolean" == typeof n2, "missing or invalid endian"), d(null != t2, "missing offset"), d(t2 + 1 < e3.length, "Trying to read beyond buffer length"));
            var o2, r2 = e3.length;
            if (!(r2 <= t2)) return n2 ? (o2 = e3[t2], t2 + 1 < r2 && (o2 |= e3[t2 + 1] << 8)) : (o2 = e3[t2] << 8, t2 + 1 < r2 && (o2 |= e3[t2 + 1])), o2;
          }
          function u(e3, t2, n2, r2) {
            r2 || (d("boolean" == typeof n2, "missing or invalid endian"), d(null != t2, "missing offset"), d(t2 + 3 < e3.length, "Trying to read beyond buffer length"));
            var o2, r2 = e3.length;
            if (!(r2 <= t2)) return n2 ? (t2 + 2 < r2 && (o2 = e3[t2 + 2] << 16), t2 + 1 < r2 && (o2 |= e3[t2 + 1] << 8), o2 |= e3[t2], t2 + 3 < r2 && (o2 += e3[t2 + 3] << 24 >>> 0)) : (t2 + 1 < r2 && (o2 = e3[t2 + 1] << 16), t2 + 2 < r2 && (o2 |= e3[t2 + 2] << 8), t2 + 3 < r2 && (o2 |= e3[t2 + 3]), o2 += e3[t2] << 24 >>> 0), o2;
          }
          function _(e3, t2, n2, r2) {
            if (r2 || (d("boolean" == typeof n2, "missing or invalid endian"), d(null != t2, "missing offset"), d(t2 + 1 < e3.length, "Trying to read beyond buffer length")), !(e3.length <= t2)) return r2 = o(e3, t2, n2, true), 32768 & r2 ? -1 * (65535 - r2 + 1) : r2;
          }
          function E(e3, t2, n2, r2) {
            if (r2 || (d("boolean" == typeof n2, "missing or invalid endian"), d(null != t2, "missing offset"), d(t2 + 3 < e3.length, "Trying to read beyond buffer length")), !(e3.length <= t2)) return r2 = u(e3, t2, n2, true), 2147483648 & r2 ? -1 * (4294967295 - r2 + 1) : r2;
          }
          function I(e3, t2, n2, r2) {
            return r2 || (d("boolean" == typeof n2, "missing or invalid endian"), d(t2 + 3 < e3.length, "Trying to read beyond buffer length")), i2.read(e3, t2, n2, 23, 4);
          }
          function A(e3, t2, n2, r2) {
            return r2 || (d("boolean" == typeof n2, "missing or invalid endian"), d(t2 + 7 < e3.length, "Trying to read beyond buffer length")), i2.read(e3, t2, n2, 52, 8);
          }
          function s(e3, t2, n2, r2, o2) {
            o2 || (d(null != t2, "missing value"), d("boolean" == typeof r2, "missing or invalid endian"), d(null != n2, "missing offset"), d(n2 + 1 < e3.length, "trying to write beyond buffer length"), Y(t2, 65535));
            o2 = e3.length;
            if (!(o2 <= n2)) for (var i3 = 0, u2 = Math.min(o2 - n2, 2); i3 < u2; i3++) e3[n2 + i3] = (t2 & 255 << 8 * (r2 ? i3 : 1 - i3)) >>> 8 * (r2 ? i3 : 1 - i3);
          }
          function l(e3, t2, n2, r2, o2) {
            o2 || (d(null != t2, "missing value"), d("boolean" == typeof r2, "missing or invalid endian"), d(null != n2, "missing offset"), d(n2 + 3 < e3.length, "trying to write beyond buffer length"), Y(t2, 4294967295));
            o2 = e3.length;
            if (!(o2 <= n2)) for (var i3 = 0, u2 = Math.min(o2 - n2, 4); i3 < u2; i3++) e3[n2 + i3] = t2 >>> 8 * (r2 ? i3 : 3 - i3) & 255;
          }
          function B(e3, t2, n2, r2, o2) {
            o2 || (d(null != t2, "missing value"), d("boolean" == typeof r2, "missing or invalid endian"), d(null != n2, "missing offset"), d(n2 + 1 < e3.length, "Trying to write beyond buffer length"), F(t2, 32767, -32768)), e3.length <= n2 || s(e3, 0 <= t2 ? t2 : 65535 + t2 + 1, n2, r2, o2);
          }
          function L(e3, t2, n2, r2, o2) {
            o2 || (d(null != t2, "missing value"), d("boolean" == typeof r2, "missing or invalid endian"), d(null != n2, "missing offset"), d(n2 + 3 < e3.length, "Trying to write beyond buffer length"), F(t2, 2147483647, -2147483648)), e3.length <= n2 || l(e3, 0 <= t2 ? t2 : 4294967295 + t2 + 1, n2, r2, o2);
          }
          function U(e3, t2, n2, r2, o2) {
            o2 || (d(null != t2, "missing value"), d("boolean" == typeof r2, "missing or invalid endian"), d(null != n2, "missing offset"), d(n2 + 3 < e3.length, "Trying to write beyond buffer length"), D(t2, 34028234663852886e22, -34028234663852886e22)), e3.length <= n2 || i2.write(e3, t2, n2, r2, 23, 4);
          }
          function x(e3, t2, n2, r2, o2) {
            o2 || (d(null != t2, "missing value"), d("boolean" == typeof r2, "missing or invalid endian"), d(null != n2, "missing offset"), d(n2 + 7 < e3.length, "Trying to write beyond buffer length"), D(t2, 17976931348623157e292, -17976931348623157e292)), e3.length <= n2 || i2.write(e3, t2, n2, r2, 52, 8);
          }
          H.Buffer = f2, H.SlowBuffer = f2, H.INSPECT_MAX_BYTES = 50, f2.poolSize = 8192, f2._useTypedArrays = function() {
            try {
              var e3 = new ArrayBuffer(0), t2 = new Uint8Array(e3);
              return t2.foo = function() {
                return 42;
              }, 42 === t2.foo() && "function" == typeof t2.subarray;
            } catch (e4) {
              return false;
            }
          }(), f2.isEncoding = function(e3) {
            switch (String(e3).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "binary":
              case "base64":
              case "raw":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return true;
              default:
                return false;
            }
          }, f2.isBuffer = function(e3) {
            return !(null == e3 || !e3._isBuffer);
          }, f2.byteLength = function(e3, t2) {
            var n2;
            switch (e3 += "", t2 || "utf8") {
              case "hex":
                n2 = e3.length / 2;
                break;
              case "utf8":
              case "utf-8":
                n2 = T(e3).length;
                break;
              case "ascii":
              case "binary":
              case "raw":
                n2 = e3.length;
                break;
              case "base64":
                n2 = M(e3).length;
                break;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                n2 = 2 * e3.length;
                break;
              default:
                throw new Error("Unknown encoding");
            }
            return n2;
          }, f2.concat = function(e3, t2) {
            if (d(C(e3), "Usage: Buffer.concat(list, [totalLength])\nlist should be an Array."), 0 === e3.length) return new f2(0);
            if (1 === e3.length) return e3[0];
            if ("number" != typeof t2) for (o2 = t2 = 0; o2 < e3.length; o2++) t2 += e3[o2].length;
            for (var n2 = new f2(t2), r2 = 0, o2 = 0; o2 < e3.length; o2++) {
              var i3 = e3[o2];
              i3.copy(n2, r2), r2 += i3.length;
            }
            return n2;
          }, f2.prototype.write = function(e3, t2, n2, r2) {
            isFinite(t2) ? isFinite(n2) || (r2 = n2, n2 = void 0) : (a2 = r2, r2 = t2, t2 = n2, n2 = a2), t2 = Number(t2) || 0;
            var o2, i3, u2, s2, a2 = this.length - t2;
            switch ((!n2 || a2 < (n2 = Number(n2))) && (n2 = a2), r2 = String(r2 || "utf8").toLowerCase()) {
              case "hex":
                o2 = function(e4, t3, n3, r3) {
                  n3 = Number(n3) || 0;
                  var o3 = e4.length - n3;
                  (!r3 || o3 < (r3 = Number(r3))) && (r3 = o3), d((o3 = t3.length) % 2 == 0, "Invalid hex string"), o3 / 2 < r3 && (r3 = o3 / 2);
                  for (var i4 = 0; i4 < r3; i4++) {
                    var u3 = parseInt(t3.substr(2 * i4, 2), 16);
                    d(!isNaN(u3), "Invalid hex string"), e4[n3 + i4] = u3;
                  }
                  return f2._charsWritten = 2 * i4, i4;
                }(this, e3, t2, n2);
                break;
              case "utf8":
              case "utf-8":
                i3 = this, u2 = t2, s2 = n2, o2 = f2._charsWritten = c(T(e3), i3, u2, s2);
                break;
              case "ascii":
              case "binary":
                o2 = b(this, e3, t2, n2);
                break;
              case "base64":
                i3 = this, u2 = t2, s2 = n2, o2 = f2._charsWritten = c(M(e3), i3, u2, s2);
                break;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                o2 = m(this, e3, t2, n2);
                break;
              default:
                throw new Error("Unknown encoding");
            }
            return o2;
          }, f2.prototype.toString = function(e3, t2, n2) {
            var r2, o2, i3, u2, s2 = this;
            if (e3 = String(e3 || "utf8").toLowerCase(), t2 = Number(t2) || 0, (n2 = void 0 !== n2 ? Number(n2) : s2.length) === t2) return "";
            switch (e3) {
              case "hex":
                r2 = function(e4, t3, n3) {
                  var r3 = e4.length;
                  (!t3 || t3 < 0) && (t3 = 0);
                  (!n3 || n3 < 0 || r3 < n3) && (n3 = r3);
                  for (var o3 = "", i4 = t3; i4 < n3; i4++) o3 += k(e4[i4]);
                  return o3;
                }(s2, t2, n2);
                break;
              case "utf8":
              case "utf-8":
                r2 = function(e4, t3, n3) {
                  var r3 = "", o3 = "";
                  n3 = Math.min(e4.length, n3);
                  for (var i4 = t3; i4 < n3; i4++) e4[i4] <= 127 ? (r3 += N(o3) + String.fromCharCode(e4[i4]), o3 = "") : o3 += "%" + e4[i4].toString(16);
                  return r3 + N(o3);
                }(s2, t2, n2);
                break;
              case "ascii":
              case "binary":
                r2 = v(s2, t2, n2);
                break;
              case "base64":
                o2 = s2, u2 = n2, r2 = 0 === (i3 = t2) && u2 === o2.length ? a.fromByteArray(o2) : a.fromByteArray(o2.slice(i3, u2));
                break;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                r2 = function(e4, t3, n3) {
                  for (var r3 = e4.slice(t3, n3), o3 = "", i4 = 0; i4 < r3.length; i4 += 2) o3 += String.fromCharCode(r3[i4] + 256 * r3[i4 + 1]);
                  return o3;
                }(s2, t2, n2);
                break;
              default:
                throw new Error("Unknown encoding");
            }
            return r2;
          }, f2.prototype.toJSON = function() {
            return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
          }, f2.prototype.copy = function(e3, t2, n2, r2) {
            if (t2 = t2 || 0, (r2 = r2 || 0 === r2 ? r2 : this.length) !== (n2 = n2 || 0) && 0 !== e3.length && 0 !== this.length) {
              d(n2 <= r2, "sourceEnd < sourceStart"), d(0 <= t2 && t2 < e3.length, "targetStart out of bounds"), d(0 <= n2 && n2 < this.length, "sourceStart out of bounds"), d(0 <= r2 && r2 <= this.length, "sourceEnd out of bounds"), r2 > this.length && (r2 = this.length);
              var o2 = (r2 = e3.length - t2 < r2 - n2 ? e3.length - t2 + n2 : r2) - n2;
              if (o2 < 100 || !f2._useTypedArrays) for (var i3 = 0; i3 < o2; i3++) e3[i3 + t2] = this[i3 + n2];
              else e3._set(this.subarray(n2, n2 + o2), t2);
            }
          }, f2.prototype.slice = function(e3, t2) {
            var n2 = this.length;
            if (e3 = S(e3, n2, 0), t2 = S(t2, n2, n2), f2._useTypedArrays) return f2._augment(this.subarray(e3, t2));
            for (var r2 = t2 - e3, o2 = new f2(r2, void 0, true), i3 = 0; i3 < r2; i3++) o2[i3] = this[i3 + e3];
            return o2;
          }, f2.prototype.get = function(e3) {
            return console.log(".get() is deprecated. Access using array indexes instead."), this.readUInt8(e3);
          }, f2.prototype.set = function(e3, t2) {
            return console.log(".set() is deprecated. Access using array indexes instead."), this.writeUInt8(e3, t2);
          }, f2.prototype.readUInt8 = function(e3, t2) {
            if (t2 || (d(null != e3, "missing offset"), d(e3 < this.length, "Trying to read beyond buffer length")), !(e3 >= this.length)) return this[e3];
          }, f2.prototype.readUInt16LE = function(e3, t2) {
            return o(this, e3, true, t2);
          }, f2.prototype.readUInt16BE = function(e3, t2) {
            return o(this, e3, false, t2);
          }, f2.prototype.readUInt32LE = function(e3, t2) {
            return u(this, e3, true, t2);
          }, f2.prototype.readUInt32BE = function(e3, t2) {
            return u(this, e3, false, t2);
          }, f2.prototype.readInt8 = function(e3, t2) {
            if (t2 || (d(null != e3, "missing offset"), d(e3 < this.length, "Trying to read beyond buffer length")), !(e3 >= this.length)) return 128 & this[e3] ? -1 * (255 - this[e3] + 1) : this[e3];
          }, f2.prototype.readInt16LE = function(e3, t2) {
            return _(this, e3, true, t2);
          }, f2.prototype.readInt16BE = function(e3, t2) {
            return _(this, e3, false, t2);
          }, f2.prototype.readInt32LE = function(e3, t2) {
            return E(this, e3, true, t2);
          }, f2.prototype.readInt32BE = function(e3, t2) {
            return E(this, e3, false, t2);
          }, f2.prototype.readFloatLE = function(e3, t2) {
            return I(this, e3, true, t2);
          }, f2.prototype.readFloatBE = function(e3, t2) {
            return I(this, e3, false, t2);
          }, f2.prototype.readDoubleLE = function(e3, t2) {
            return A(this, e3, true, t2);
          }, f2.prototype.readDoubleBE = function(e3, t2) {
            return A(this, e3, false, t2);
          }, f2.prototype.writeUInt8 = function(e3, t2, n2) {
            n2 || (d(null != e3, "missing value"), d(null != t2, "missing offset"), d(t2 < this.length, "trying to write beyond buffer length"), Y(e3, 255)), t2 >= this.length || (this[t2] = e3);
          }, f2.prototype.writeUInt16LE = function(e3, t2, n2) {
            s(this, e3, t2, true, n2);
          }, f2.prototype.writeUInt16BE = function(e3, t2, n2) {
            s(this, e3, t2, false, n2);
          }, f2.prototype.writeUInt32LE = function(e3, t2, n2) {
            l(this, e3, t2, true, n2);
          }, f2.prototype.writeUInt32BE = function(e3, t2, n2) {
            l(this, e3, t2, false, n2);
          }, f2.prototype.writeInt8 = function(e3, t2, n2) {
            n2 || (d(null != e3, "missing value"), d(null != t2, "missing offset"), d(t2 < this.length, "Trying to write beyond buffer length"), F(e3, 127, -128)), t2 >= this.length || (0 <= e3 ? this.writeUInt8(e3, t2, n2) : this.writeUInt8(255 + e3 + 1, t2, n2));
          }, f2.prototype.writeInt16LE = function(e3, t2, n2) {
            B(this, e3, t2, true, n2);
          }, f2.prototype.writeInt16BE = function(e3, t2, n2) {
            B(this, e3, t2, false, n2);
          }, f2.prototype.writeInt32LE = function(e3, t2, n2) {
            L(this, e3, t2, true, n2);
          }, f2.prototype.writeInt32BE = function(e3, t2, n2) {
            L(this, e3, t2, false, n2);
          }, f2.prototype.writeFloatLE = function(e3, t2, n2) {
            U(this, e3, t2, true, n2);
          }, f2.prototype.writeFloatBE = function(e3, t2, n2) {
            U(this, e3, t2, false, n2);
          }, f2.prototype.writeDoubleLE = function(e3, t2, n2) {
            x(this, e3, t2, true, n2);
          }, f2.prototype.writeDoubleBE = function(e3, t2, n2) {
            x(this, e3, t2, false, n2);
          }, f2.prototype.fill = function(e3, t2, n2) {
            if (t2 = t2 || 0, n2 = n2 || this.length, d("number" == typeof (e3 = "string" == typeof (e3 = e3 || 0) ? e3.charCodeAt(0) : e3) && !isNaN(e3), "value is not a number"), d(t2 <= n2, "end < start"), n2 !== t2 && 0 !== this.length) {
              d(0 <= t2 && t2 < this.length, "start out of bounds"), d(0 <= n2 && n2 <= this.length, "end out of bounds");
              for (var r2 = t2; r2 < n2; r2++) this[r2] = e3;
            }
          }, f2.prototype.inspect = function() {
            for (var e3 = [], t2 = this.length, n2 = 0; n2 < t2; n2++) if (e3[n2] = k(this[n2]), n2 === H.INSPECT_MAX_BYTES) {
              e3[n2 + 1] = "...";
              break;
            }
            return "<Buffer " + e3.join(" ") + ">";
          }, f2.prototype.toArrayBuffer = function() {
            if ("undefined" == typeof Uint8Array) throw new Error("Buffer.toArrayBuffer not supported in this browser");
            if (f2._useTypedArrays) return new f2(this).buffer;
            for (var e3 = new Uint8Array(this.length), t2 = 0, n2 = e3.length; t2 < n2; t2 += 1) e3[t2] = this[t2];
            return e3.buffer;
          };
          var t = f2.prototype;
          function S(e3, t2, n2) {
            return "number" != typeof e3 ? n2 : t2 <= (e3 = ~~e3) ? t2 : 0 <= e3 || 0 <= (e3 += t2) ? e3 : 0;
          }
          function j(e3) {
            return (e3 = ~~Math.ceil(+e3)) < 0 ? 0 : e3;
          }
          function C(e3) {
            return (Array.isArray || function(e4) {
              return "[object Array]" === Object.prototype.toString.call(e4);
            })(e3);
          }
          function k(e3) {
            return e3 < 16 ? "0" + e3.toString(16) : e3.toString(16);
          }
          function T(e3) {
            for (var t2 = [], n2 = 0; n2 < e3.length; n2++) {
              var r2 = e3.charCodeAt(n2);
              if (r2 <= 127) t2.push(e3.charCodeAt(n2));
              else for (var o2 = n2, i3 = (55296 <= r2 && r2 <= 57343 && n2++, encodeURIComponent(e3.slice(o2, n2 + 1)).substr(1).split("%")), u2 = 0; u2 < i3.length; u2++) t2.push(parseInt(i3[u2], 16));
            }
            return t2;
          }
          function M(e3) {
            return a.toByteArray(e3);
          }
          function c(e3, t2, n2, r2) {
            for (var o2 = 0; o2 < r2 && !(o2 + n2 >= t2.length || o2 >= e3.length); o2++) t2[o2 + n2] = e3[o2];
            return o2;
          }
          function N(e3) {
            try {
              return decodeURIComponent(e3);
            } catch (e4) {
              return String.fromCharCode(65533);
            }
          }
          function Y(e3, t2) {
            d("number" == typeof e3, "cannot write a non-number as a number"), d(0 <= e3, "specified a negative value for writing an unsigned value"), d(e3 <= t2, "value is larger than maximum value for type"), d(Math.floor(e3) === e3, "value has a fractional component");
          }
          function F(e3, t2, n2) {
            d("number" == typeof e3, "cannot write a non-number as a number"), d(e3 <= t2, "value larger than maximum allowed value"), d(n2 <= e3, "value smaller than minimum allowed value"), d(Math.floor(e3) === e3, "value has a fractional component");
          }
          function D(e3, t2, n2) {
            d("number" == typeof e3, "cannot write a non-number as a number"), d(e3 <= t2, "value larger than maximum allowed value"), d(n2 <= e3, "value smaller than minimum allowed value");
          }
          function d(e3, t2) {
            if (!e3) throw new Error(t2 || "Failed assertion");
          }
          f2._augment = function(e3) {
            return e3._isBuffer = true, e3._get = e3.get, e3._set = e3.set, e3.get = t.get, e3.set = t.set, e3.write = t.write, e3.toString = t.toString, e3.toLocaleString = t.toString, e3.toJSON = t.toJSON, e3.copy = t.copy, e3.slice = t.slice, e3.readUInt8 = t.readUInt8, e3.readUInt16LE = t.readUInt16LE, e3.readUInt16BE = t.readUInt16BE, e3.readUInt32LE = t.readUInt32LE, e3.readUInt32BE = t.readUInt32BE, e3.readInt8 = t.readInt8, e3.readInt16LE = t.readInt16LE, e3.readInt16BE = t.readInt16BE, e3.readInt32LE = t.readInt32LE, e3.readInt32BE = t.readInt32BE, e3.readFloatLE = t.readFloatLE, e3.readFloatBE = t.readFloatBE, e3.readDoubleLE = t.readDoubleLE, e3.readDoubleBE = t.readDoubleBE, e3.writeUInt8 = t.writeUInt8, e3.writeUInt16LE = t.writeUInt16LE, e3.writeUInt16BE = t.writeUInt16BE, e3.writeUInt32LE = t.writeUInt32LE, e3.writeUInt32BE = t.writeUInt32BE, e3.writeInt8 = t.writeInt8, e3.writeInt16LE = t.writeInt16LE, e3.writeInt16BE = t.writeInt16BE, e3.writeInt32LE = t.writeInt32LE, e3.writeInt32BE = t.writeInt32BE, e3.writeFloatLE = t.writeFloatLE, e3.writeFloatBE = t.writeFloatBE, e3.writeDoubleLE = t.writeDoubleLE, e3.writeDoubleBE = t.writeDoubleBE, e3.fill = t.fill, e3.inspect = t.inspect, e3.toArrayBuffer = t.toArrayBuffer, e3;
          };
        }).call(this, O("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, O("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/buffer/index.js", "/node_modules/gulp-browserify/node_modules/buffer");
      }, { "base64-js": 2, buffer: 3, ieee754: 10, lYpoI2: 11 }], 4: [function(c, d, e) {
        !(function(e2, t, a, n, r, o, i2, u, s) {
          var a = c("buffer").Buffer, f2 = 4, l = new a(f2);
          l.fill(0);
          d.exports = { hash: function(e3, t2, n2, r2) {
            for (var o2 = t2(function(e4, t3) {
              e4.length % f2 != 0 && (n3 = e4.length + (f2 - e4.length % f2), e4 = a.concat([e4, l], n3));
              for (var n3, r3 = [], o3 = t3 ? e4.readInt32BE : e4.readInt32LE, i4 = 0; i4 < e4.length; i4 += f2) r3.push(o3.call(e4, i4));
              return r3;
            }(e3 = a.isBuffer(e3) ? e3 : new a(e3), r2), 8 * e3.length), t2 = r2, i3 = new a(n2), u2 = t2 ? i3.writeInt32BE : i3.writeInt32LE, s2 = 0; s2 < o2.length; s2++) u2.call(i3, o2[s2], 4 * s2, true);
            return i3;
          } };
        }).call(this, c("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, c("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/helpers.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { buffer: 3, lYpoI2: 11 }], 5: [function(v, e, _) {
        !(function(l, c, u, d, h, p, g, y, w) {
          var u = v("buffer").Buffer, e2 = v("./sha"), t = v("./sha256"), n = v("./rng"), b = { sha1: e2, sha256: t, md5: v("./md5") }, s = 64, a = new u(s);
          function r(e3, n2) {
            var r2 = b[e3 = e3 || "sha1"], o2 = [];
            return r2 || i2("algorithm:", e3, "is not yet supported"), { update: function(e4) {
              return u.isBuffer(e4) || (e4 = new u(e4)), o2.push(e4), e4.length, this;
            }, digest: function(e4) {
              var t2 = u.concat(o2), t2 = n2 ? function(e5, t3, n3) {
                u.isBuffer(t3) || (t3 = new u(t3)), u.isBuffer(n3) || (n3 = new u(n3)), t3.length > s ? t3 = e5(t3) : t3.length < s && (t3 = u.concat([t3, a], s));
                for (var r3 = new u(s), o3 = new u(s), i3 = 0; i3 < s; i3++) r3[i3] = 54 ^ t3[i3], o3[i3] = 92 ^ t3[i3];
                return n3 = e5(u.concat([r3, n3])), e5(u.concat([o3, n3]));
              }(r2, n2, t2) : r2(t2);
              return o2 = null, e4 ? t2.toString(e4) : t2;
            } };
          }
          function i2() {
            var e3 = [].slice.call(arguments).join(" ");
            throw new Error([e3, "we accept pull requests", "http://github.com/dominictarr/crypto-browserify"].join("\n"));
          }
          a.fill(0), _.createHash = function(e3) {
            return r(e3);
          }, _.createHmac = r, _.randomBytes = function(e3, t2) {
            if (!t2 || !t2.call) return new u(n(e3));
            try {
              t2.call(this, void 0, new u(n(e3)));
            } catch (e4) {
              t2(e4);
            }
          };
          var o, f2 = ["createCredentials", "createCipher", "createCipheriv", "createDecipher", "createDecipheriv", "createSign", "createVerify", "createDiffieHellman", "pbkdf2"], m = function(e3) {
            _[e3] = function() {
              i2("sorry,", e3, "is not implemented yet");
            };
          };
          for (o in f2) m(f2[o], o);
        }).call(this, v("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, v("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/index.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./md5": 6, "./rng": 7, "./sha": 8, "./sha256": 9, buffer: 3, lYpoI2: 11 }], 6: [function(w, b, e) {
        !(function(e2, r, o, i2, u, a, f2, l, y) {
          var t = w("./helpers");
          function n(e3, t2) {
            e3[t2 >> 5] |= 128 << t2 % 32, e3[14 + (t2 + 64 >>> 9 << 4)] = t2;
            for (var n2 = 1732584193, r2 = -271733879, o2 = -1732584194, i3 = 271733878, u2 = 0; u2 < e3.length; u2 += 16) {
              var s2 = n2, a2 = r2, f3 = o2, l2 = i3, n2 = c(n2, r2, o2, i3, e3[u2 + 0], 7, -680876936), i3 = c(i3, n2, r2, o2, e3[u2 + 1], 12, -389564586), o2 = c(o2, i3, n2, r2, e3[u2 + 2], 17, 606105819), r2 = c(r2, o2, i3, n2, e3[u2 + 3], 22, -1044525330);
              n2 = c(n2, r2, o2, i3, e3[u2 + 4], 7, -176418897), i3 = c(i3, n2, r2, o2, e3[u2 + 5], 12, 1200080426), o2 = c(o2, i3, n2, r2, e3[u2 + 6], 17, -1473231341), r2 = c(r2, o2, i3, n2, e3[u2 + 7], 22, -45705983), n2 = c(n2, r2, o2, i3, e3[u2 + 8], 7, 1770035416), i3 = c(i3, n2, r2, o2, e3[u2 + 9], 12, -1958414417), o2 = c(o2, i3, n2, r2, e3[u2 + 10], 17, -42063), r2 = c(r2, o2, i3, n2, e3[u2 + 11], 22, -1990404162), n2 = c(n2, r2, o2, i3, e3[u2 + 12], 7, 1804603682), i3 = c(i3, n2, r2, o2, e3[u2 + 13], 12, -40341101), o2 = c(o2, i3, n2, r2, e3[u2 + 14], 17, -1502002290), n2 = d(n2, r2 = c(r2, o2, i3, n2, e3[u2 + 15], 22, 1236535329), o2, i3, e3[u2 + 1], 5, -165796510), i3 = d(i3, n2, r2, o2, e3[u2 + 6], 9, -1069501632), o2 = d(o2, i3, n2, r2, e3[u2 + 11], 14, 643717713), r2 = d(r2, o2, i3, n2, e3[u2 + 0], 20, -373897302), n2 = d(n2, r2, o2, i3, e3[u2 + 5], 5, -701558691), i3 = d(i3, n2, r2, o2, e3[u2 + 10], 9, 38016083), o2 = d(o2, i3, n2, r2, e3[u2 + 15], 14, -660478335), r2 = d(r2, o2, i3, n2, e3[u2 + 4], 20, -405537848), n2 = d(n2, r2, o2, i3, e3[u2 + 9], 5, 568446438), i3 = d(i3, n2, r2, o2, e3[u2 + 14], 9, -1019803690), o2 = d(o2, i3, n2, r2, e3[u2 + 3], 14, -187363961), r2 = d(r2, o2, i3, n2, e3[u2 + 8], 20, 1163531501), n2 = d(n2, r2, o2, i3, e3[u2 + 13], 5, -1444681467), i3 = d(i3, n2, r2, o2, e3[u2 + 2], 9, -51403784), o2 = d(o2, i3, n2, r2, e3[u2 + 7], 14, 1735328473), n2 = h(n2, r2 = d(r2, o2, i3, n2, e3[u2 + 12], 20, -1926607734), o2, i3, e3[u2 + 5], 4, -378558), i3 = h(i3, n2, r2, o2, e3[u2 + 8], 11, -2022574463), o2 = h(o2, i3, n2, r2, e3[u2 + 11], 16, 1839030562), r2 = h(r2, o2, i3, n2, e3[u2 + 14], 23, -35309556), n2 = h(n2, r2, o2, i3, e3[u2 + 1], 4, -1530992060), i3 = h(i3, n2, r2, o2, e3[u2 + 4], 11, 1272893353), o2 = h(o2, i3, n2, r2, e3[u2 + 7], 16, -155497632), r2 = h(r2, o2, i3, n2, e3[u2 + 10], 23, -1094730640), n2 = h(n2, r2, o2, i3, e3[u2 + 13], 4, 681279174), i3 = h(i3, n2, r2, o2, e3[u2 + 0], 11, -358537222), o2 = h(o2, i3, n2, r2, e3[u2 + 3], 16, -722521979), r2 = h(r2, o2, i3, n2, e3[u2 + 6], 23, 76029189), n2 = h(n2, r2, o2, i3, e3[u2 + 9], 4, -640364487), i3 = h(i3, n2, r2, o2, e3[u2 + 12], 11, -421815835), o2 = h(o2, i3, n2, r2, e3[u2 + 15], 16, 530742520), n2 = p(n2, r2 = h(r2, o2, i3, n2, e3[u2 + 2], 23, -995338651), o2, i3, e3[u2 + 0], 6, -198630844), i3 = p(i3, n2, r2, o2, e3[u2 + 7], 10, 1126891415), o2 = p(o2, i3, n2, r2, e3[u2 + 14], 15, -1416354905), r2 = p(r2, o2, i3, n2, e3[u2 + 5], 21, -57434055), n2 = p(n2, r2, o2, i3, e3[u2 + 12], 6, 1700485571), i3 = p(i3, n2, r2, o2, e3[u2 + 3], 10, -1894986606), o2 = p(o2, i3, n2, r2, e3[u2 + 10], 15, -1051523), r2 = p(r2, o2, i3, n2, e3[u2 + 1], 21, -2054922799), n2 = p(n2, r2, o2, i3, e3[u2 + 8], 6, 1873313359), i3 = p(i3, n2, r2, o2, e3[u2 + 15], 10, -30611744), o2 = p(o2, i3, n2, r2, e3[u2 + 6], 15, -1560198380), r2 = p(r2, o2, i3, n2, e3[u2 + 13], 21, 1309151649), n2 = p(n2, r2, o2, i3, e3[u2 + 4], 6, -145523070), i3 = p(i3, n2, r2, o2, e3[u2 + 11], 10, -1120210379), o2 = p(o2, i3, n2, r2, e3[u2 + 2], 15, 718787259), r2 = p(r2, o2, i3, n2, e3[u2 + 9], 21, -343485551), n2 = g(n2, s2), r2 = g(r2, a2), o2 = g(o2, f3), i3 = g(i3, l2);
            }
            return Array(n2, r2, o2, i3);
          }
          function s(e3, t2, n2, r2, o2, i3) {
            return g((t2 = g(g(t2, e3), g(r2, i3))) << o2 | t2 >>> 32 - o2, n2);
          }
          function c(e3, t2, n2, r2, o2, i3, u2) {
            return s(t2 & n2 | ~t2 & r2, e3, t2, o2, i3, u2);
          }
          function d(e3, t2, n2, r2, o2, i3, u2) {
            return s(t2 & r2 | n2 & ~r2, e3, t2, o2, i3, u2);
          }
          function h(e3, t2, n2, r2, o2, i3, u2) {
            return s(t2 ^ n2 ^ r2, e3, t2, o2, i3, u2);
          }
          function p(e3, t2, n2, r2, o2, i3, u2) {
            return s(n2 ^ (t2 | ~r2), e3, t2, o2, i3, u2);
          }
          function g(e3, t2) {
            var n2 = (65535 & e3) + (65535 & t2);
            return (e3 >> 16) + (t2 >> 16) + (n2 >> 16) << 16 | 65535 & n2;
          }
          b.exports = function(e3) {
            return t.hash(e3, n, 16);
          };
        }).call(this, w("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, w("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/md5.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 7: [function(e, l, t) {
        !(function(e2, t2, n, r, o, i2, u, s, f2) {
          var a;
          l.exports = a || function(e3) {
            for (var t3, n2 = new Array(e3), r2 = 0; r2 < e3; r2++) 0 == (3 & r2) && (t3 = 4294967296 * Math.random()), n2[r2] = t3 >>> ((3 & r2) << 3) & 255;
            return n2;
          };
        }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/rng.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { buffer: 3, lYpoI2: 11 }], 8: [function(c, d, e) {
        !(function(e2, t, n, r, o, s, a, f2, l) {
          var i2 = c("./helpers");
          function u(l2, c2) {
            l2[c2 >> 5] |= 128 << 24 - c2 % 32, l2[15 + (c2 + 64 >> 9 << 4)] = c2;
            for (var e3, t2, n2, r2 = Array(80), o2 = 1732584193, i3 = -271733879, u2 = -1732584194, s2 = 271733878, d2 = -1009589776, h = 0; h < l2.length; h += 16) {
              for (var p = o2, g = i3, y = u2, w = s2, b = d2, a2 = 0; a2 < 80; a2++) {
                r2[a2] = a2 < 16 ? l2[h + a2] : v(r2[a2 - 3] ^ r2[a2 - 8] ^ r2[a2 - 14] ^ r2[a2 - 16], 1);
                var f3 = m(m(v(o2, 5), (f3 = i3, t2 = u2, n2 = s2, (e3 = a2) < 20 ? f3 & t2 | ~f3 & n2 : !(e3 < 40) && e3 < 60 ? f3 & t2 | f3 & n2 | t2 & n2 : f3 ^ t2 ^ n2)), m(m(d2, r2[a2]), (e3 = a2) < 20 ? 1518500249 : e3 < 40 ? 1859775393 : e3 < 60 ? -1894007588 : -899497514)), d2 = s2, s2 = u2, u2 = v(i3, 30), i3 = o2, o2 = f3;
              }
              o2 = m(o2, p), i3 = m(i3, g), u2 = m(u2, y), s2 = m(s2, w), d2 = m(d2, b);
            }
            return Array(o2, i3, u2, s2, d2);
          }
          function m(e3, t2) {
            var n2 = (65535 & e3) + (65535 & t2);
            return (e3 >> 16) + (t2 >> 16) + (n2 >> 16) << 16 | 65535 & n2;
          }
          function v(e3, t2) {
            return e3 << t2 | e3 >>> 32 - t2;
          }
          d.exports = function(e3) {
            return i2.hash(e3, u, 20, true);
          };
        }).call(this, c("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, c("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 9: [function(c, d, e) {
        !(function(e2, t, n, r, u, s, a, f2, l) {
          function b(e3, t2) {
            var n2 = (65535 & e3) + (65535 & t2);
            return (e3 >> 16) + (t2 >> 16) + (n2 >> 16) << 16 | 65535 & n2;
          }
          function o(e3, l2) {
            var c2, d2 = new Array(1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298), t2 = new Array(1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225), n2 = new Array(64);
            e3[l2 >> 5] |= 128 << 24 - l2 % 32, e3[15 + (l2 + 64 >> 9 << 4)] = l2;
            for (var r2, o2, h = 0; h < e3.length; h += 16) {
              for (var i3 = t2[0], u2 = t2[1], s2 = t2[2], p = t2[3], a2 = t2[4], g = t2[5], y = t2[6], w = t2[7], f3 = 0; f3 < 64; f3++) n2[f3] = f3 < 16 ? e3[f3 + h] : b(b(b((o2 = n2[f3 - 2], m(o2, 17) ^ m(o2, 19) ^ v(o2, 10)), n2[f3 - 7]), (o2 = n2[f3 - 15], m(o2, 7) ^ m(o2, 18) ^ v(o2, 3))), n2[f3 - 16]), c2 = b(b(b(b(w, m(o2 = a2, 6) ^ m(o2, 11) ^ m(o2, 25)), a2 & g ^ ~a2 & y), d2[f3]), n2[f3]), r2 = b(m(r2 = i3, 2) ^ m(r2, 13) ^ m(r2, 22), i3 & u2 ^ i3 & s2 ^ u2 & s2), w = y, y = g, g = a2, a2 = b(p, c2), p = s2, s2 = u2, u2 = i3, i3 = b(c2, r2);
              t2[0] = b(i3, t2[0]), t2[1] = b(u2, t2[1]), t2[2] = b(s2, t2[2]), t2[3] = b(p, t2[3]), t2[4] = b(a2, t2[4]), t2[5] = b(g, t2[5]), t2[6] = b(y, t2[6]), t2[7] = b(w, t2[7]);
            }
            return t2;
          }
          var i2 = c("./helpers"), m = function(e3, t2) {
            return e3 >>> t2 | e3 << 32 - t2;
          }, v = function(e3, t2) {
            return e3 >>> t2;
          };
          d.exports = function(e3) {
            return i2.hash(e3, o, 32, true);
          };
        }).call(this, c("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, c("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha256.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 10: [function(e, t, f2) {
        !(function(e2, t2, n, r, o, i2, u, s, a) {
          f2.read = function(e3, t3, n2, r2, o2) {
            var i3, u2, l = 8 * o2 - r2 - 1, c = (1 << l) - 1, d = c >> 1, s2 = -7, a2 = n2 ? o2 - 1 : 0, f3 = n2 ? -1 : 1, o2 = e3[t3 + a2];
            for (a2 += f3, i3 = o2 & (1 << -s2) - 1, o2 >>= -s2, s2 += l; 0 < s2; i3 = 256 * i3 + e3[t3 + a2], a2 += f3, s2 -= 8) ;
            for (u2 = i3 & (1 << -s2) - 1, i3 >>= -s2, s2 += r2; 0 < s2; u2 = 256 * u2 + e3[t3 + a2], a2 += f3, s2 -= 8) ;
            if (0 === i3) i3 = 1 - d;
            else {
              if (i3 === c) return u2 ? NaN : 1 / 0 * (o2 ? -1 : 1);
              u2 += Math.pow(2, r2), i3 -= d;
            }
            return (o2 ? -1 : 1) * u2 * Math.pow(2, i3 - r2);
          }, f2.write = function(e3, t3, l, n2, r2, c) {
            var o2, i3, u2 = 8 * c - r2 - 1, s2 = (1 << u2) - 1, a2 = s2 >> 1, d = 23 === r2 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f3 = n2 ? 0 : c - 1, h = n2 ? 1 : -1, c = t3 < 0 || 0 === t3 && 1 / t3 < 0 ? 1 : 0;
            for (t3 = Math.abs(t3), isNaN(t3) || t3 === 1 / 0 ? (i3 = isNaN(t3) ? 1 : 0, o2 = s2) : (o2 = Math.floor(Math.log(t3) / Math.LN2), t3 * (n2 = Math.pow(2, -o2)) < 1 && (o2--, n2 *= 2), 2 <= (t3 += 1 <= o2 + a2 ? d / n2 : d * Math.pow(2, 1 - a2)) * n2 && (o2++, n2 /= 2), s2 <= o2 + a2 ? (i3 = 0, o2 = s2) : 1 <= o2 + a2 ? (i3 = (t3 * n2 - 1) * Math.pow(2, r2), o2 += a2) : (i3 = t3 * Math.pow(2, a2 - 1) * Math.pow(2, r2), o2 = 0)); 8 <= r2; e3[l + f3] = 255 & i3, f3 += h, i3 /= 256, r2 -= 8) ;
            for (o2 = o2 << r2 | i3, u2 += r2; 0 < u2; e3[l + f3] = 255 & o2, f3 += h, o2 /= 256, u2 -= 8) ;
            e3[l + f3 - h] |= 128 * c;
          };
        }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/ieee754/index.js", "/node_modules/gulp-browserify/node_modules/ieee754");
      }, { buffer: 3, lYpoI2: 11 }], 11: [function(e, h, t) {
        !(function(e2, t2, n, r, o, f2, l, c, d) {
          var i2, u, s;
          function a() {
          }
          (e2 = h.exports = {}).nextTick = (u = "undefined" != typeof window && window.setImmediate, s = "undefined" != typeof window && window.postMessage && window.addEventListener, u ? function(e3) {
            return window.setImmediate(e3);
          } : s ? (i2 = [], window.addEventListener("message", function(e3) {
            var t3 = e3.source;
            t3 !== window && null !== t3 || "process-tick" !== e3.data || (e3.stopPropagation(), 0 < i2.length && i2.shift()());
          }, true), function(e3) {
            i2.push(e3), window.postMessage("process-tick", "*");
          }) : function(e3) {
            setTimeout(e3, 0);
          }), e2.title = "browser", e2.browser = true, e2.env = {}, e2.argv = [], e2.on = a, e2.addListener = a, e2.once = a, e2.off = a, e2.removeListener = a, e2.removeAllListeners = a, e2.emit = a, e2.binding = function(e3) {
            throw new Error("process.binding is not supported");
          }, e2.cwd = function() {
            return "/";
          }, e2.chdir = function(e3) {
            throw new Error("process.chdir is not supported");
          };
        }).call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/process/browser.js", "/node_modules/gulp-browserify/node_modules/process");
      }, { buffer: 3, lYpoI2: 11 }] }, {}, [1])(1);
    });
  }
});

// ../node_modules/@instantdb/core/dist/module/utils/log.js
var log = (() => {
  let isEnabled = false;
  if (typeof window !== "undefined" && typeof window.localStorage !== "undefined") {
    isEnabled = !!window.localStorage.getItem("loggingEnabled");
  } else {
    isEnabled = false;
  }
  function makeLogger(fnName) {
    return (...args) => {
      if (!isEnabled)
        return;
      console[fnName](...args);
    };
  }
  return {
    info: makeLogger("info"),
    debug: makeLogger("debug"),
    error: makeLogger("error")
  };
})();
var log_default = log;

// ../node_modules/@instantdb/core/dist/module/utils/weakHash.js
var import_object_hash = __toESM(require_object_hash());
var weakHash = import_object_hash.MD5;
var weakHash_default = weakHash;

// ../node_modules/mutative/dist/mutative.esm.mjs
var Operation = {
  Remove: "remove",
  Replace: "replace",
  Add: "add"
};
var PROXY_DRAFT = Symbol.for("__MUTATIVE_PROXY_DRAFT__");
var RAW_RETURN_SYMBOL = Symbol("__MUTATIVE_RAW_RETURN_SYMBOL__");
var iteratorSymbol = Symbol.iterator;
var dataTypes = {
  mutable: "mutable",
  immutable: "immutable"
};
var internal = {};
function has(target, key) {
  return target instanceof Map ? target.has(key) : Object.prototype.hasOwnProperty.call(target, key);
}
function getDescriptor(target, key) {
  if (key in target) {
    let prototype = Reflect.getPrototypeOf(target);
    while (prototype) {
      const descriptor = Reflect.getOwnPropertyDescriptor(prototype, key);
      if (descriptor)
        return descriptor;
      prototype = Reflect.getPrototypeOf(prototype);
    }
  }
  return;
}
function latest(proxyDraft) {
  var _a;
  return (_a = proxyDraft.copy) !== null && _a !== void 0 ? _a : proxyDraft.original;
}
function isDraft(target) {
  return !!getProxyDraft(target);
}
function getProxyDraft(value) {
  if (typeof value !== "object")
    return null;
  return value === null || value === void 0 ? void 0 : value[PROXY_DRAFT];
}
function getValue(value) {
  var _a;
  const proxyDraft = getProxyDraft(value);
  return proxyDraft ? (_a = proxyDraft.copy) !== null && _a !== void 0 ? _a : proxyDraft.original : value;
}
function isDraftable(value, options) {
  if (!value || typeof value !== "object")
    return false;
  let markResult;
  return Object.getPrototypeOf(value) === Object.prototype || Array.isArray(value) || value instanceof Map || value instanceof Set || !!(options === null || options === void 0 ? void 0 : options.mark) && ((markResult = options.mark(value, dataTypes)) === dataTypes.immutable || typeof markResult === "function");
}
function getPath(target, path = []) {
  if (Object.hasOwnProperty.call(target, "key")) {
    const parentCopy = target.parent.copy;
    const proxyDraft = getProxyDraft(get(parentCopy, target.key));
    if (proxyDraft !== null && (proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.original) !== target.original) {
      return null;
    }
    const isSet = target.parent.type === 3;
    const key = isSet ? Array.from(target.parent.setMap.keys()).indexOf(target.key) : target.key;
    if (!(isSet && parentCopy.size > key || has(parentCopy, key)))
      return null;
    path.push(key);
  }
  if (target.parent) {
    return getPath(target.parent, path);
  }
  path.reverse();
  try {
    resolvePath(target.copy, path);
  } catch (e) {
    return null;
  }
  return path;
}
function getType(target) {
  if (Array.isArray(target))
    return 1;
  if (target instanceof Map)
    return 2;
  if (target instanceof Set)
    return 3;
  return 0;
}
function get(target, key) {
  return getType(target) === 2 ? target.get(key) : target[key];
}
function set(target, key, value) {
  const type = getType(target);
  if (type === 2) {
    target.set(key, value);
  } else {
    target[key] = value;
  }
}
function peek(target, key) {
  const state = getProxyDraft(target);
  const source = state ? latest(state) : target;
  return source[key];
}
function isEqual(x, y) {
  if (x === y) {
    return x !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}
function revokeProxy(proxyDraft) {
  if (!proxyDraft)
    return;
  while (proxyDraft.finalities.revoke.length > 0) {
    const revoke = proxyDraft.finalities.revoke.pop();
    revoke();
  }
}
function escapePath(path, pathAsArray) {
  return pathAsArray ? path : [""].concat(path).map((_item) => {
    const item = `${_item}`;
    if (item.indexOf("/") === -1 && item.indexOf("~") === -1)
      return item;
    return item.replace(/~/g, "~0").replace(/\//g, "~1");
  }).join("/");
}
function resolvePath(base, path) {
  for (let index = 0; index < path.length - 1; index += 1) {
    const key = path[index];
    base = get(getType(base) === 3 ? Array.from(base) : base, key);
    if (typeof base !== "object") {
      throw new Error(`Cannot resolve patch at '${path.join("/")}'.`);
    }
  }
  return base;
}
function strictCopy(target) {
  const copy = Object.create(Object.getPrototypeOf(target));
  Reflect.ownKeys(target).forEach((key) => {
    let desc = Reflect.getOwnPropertyDescriptor(target, key);
    if (desc.enumerable && desc.configurable && desc.writable) {
      copy[key] = target[key];
      return;
    }
    if (!desc.writable) {
      desc.writable = true;
      desc.configurable = true;
    }
    if (desc.get || desc.set)
      desc = {
        configurable: true,
        writable: true,
        enumerable: desc.enumerable,
        value: target[key]
      };
    Reflect.defineProperty(copy, key, desc);
  });
  return copy;
}
var propIsEnum = Object.prototype.propertyIsEnumerable;
function shallowCopy(original, options) {
  let markResult;
  if (Array.isArray(original)) {
    return Array.prototype.concat.call(original);
  } else if (original instanceof Set) {
    return new Set(original.values());
  } else if (original instanceof Map) {
    return new Map(original);
  } else if ((options === null || options === void 0 ? void 0 : options.mark) && (markResult = options.mark(original, dataTypes), markResult !== void 0) && markResult !== dataTypes.mutable) {
    if (markResult === dataTypes.immutable) {
      return strictCopy(original);
    } else if (typeof markResult === "function") {
      if (options.enablePatches || options.enableAutoFreeze) {
        throw new Error(`You can't use mark and patches or auto freeze together.`);
      }
      return markResult();
    }
    throw new Error(`Unsupported mark result: ${markResult}`);
  } else if (typeof original === "object" && Object.getPrototypeOf(original) === Object.prototype) {
    const copy = {};
    Object.keys(original).forEach((key) => {
      copy[key] = original[key];
    });
    Object.getOwnPropertySymbols(original).forEach((key) => {
      if (propIsEnum.call(original, key)) {
        copy[key] = original[key];
      }
    });
    return copy;
  } else {
    throw new Error(`Please check mark() to ensure that it is a stable marker draftable function.`);
  }
}
function ensureShallowCopy(target) {
  if (target.copy)
    return;
  target.copy = shallowCopy(target.original, target.options);
}
function deepClone(target) {
  if (!isDraftable(target))
    return getValue(target);
  if (Array.isArray(target))
    return target.map(deepClone);
  if (target instanceof Map)
    return new Map(Array.from(target.entries()).map(([k, v]) => [k, deepClone(v)]));
  if (target instanceof Set)
    return new Set(Array.from(target).map(deepClone));
  const copy = Object.create(Object.getPrototypeOf(target));
  for (const key in target)
    copy[key] = deepClone(target[key]);
  return copy;
}
function cloneIfNeeded(target) {
  return isDraft(target) ? deepClone(target) : target;
}
function markChanged(proxyDraft) {
  var _a;
  proxyDraft.assignedMap = (_a = proxyDraft.assignedMap) !== null && _a !== void 0 ? _a : /* @__PURE__ */ new Map();
  if (!proxyDraft.operated) {
    proxyDraft.operated = true;
    if (proxyDraft.parent) {
      markChanged(proxyDraft.parent);
    }
  }
}
function throwFrozenError() {
  throw new Error("Cannot modify frozen object");
}
function deepFreeze(target, subKey, updatedValues, stack, keys) {
  {
    updatedValues = updatedValues !== null && updatedValues !== void 0 ? updatedValues : /* @__PURE__ */ new WeakMap();
    stack = stack !== null && stack !== void 0 ? stack : [];
    keys = keys !== null && keys !== void 0 ? keys : [];
    const value = updatedValues.has(target) ? updatedValues.get(target) : target;
    if (stack.length > 0) {
      const index = stack.indexOf(value);
      if (value && typeof value === "object" && index !== -1) {
        if (stack[0] === value) {
          throw new Error(`Forbids circular reference`);
        }
        throw new Error(`Forbids circular reference: ~/${keys.slice(0, index).map((key, index2) => {
          if (typeof key === "symbol")
            return `[${key.toString()}]`;
          const parent = stack[index2];
          if (typeof key === "object" && (parent instanceof Map || parent instanceof Set))
            return Array.from(parent.keys()).indexOf(key);
          return key;
        }).join("/")}`);
      }
      stack.push(value);
      keys.push(subKey);
    } else {
      stack.push(value);
    }
  }
  if (Object.isFrozen(target) || isDraft(target)) {
    {
      stack.pop();
      keys.pop();
    }
    return;
  }
  const type = getType(target);
  switch (type) {
    case 2:
      for (const [key, value] of target) {
        deepFreeze(key, key, updatedValues, stack, keys);
        deepFreeze(value, key, updatedValues, stack, keys);
      }
      target.set = target.clear = target.delete = throwFrozenError;
      break;
    case 3:
      for (const value of target) {
        deepFreeze(value, value, updatedValues, stack, keys);
      }
      target.add = target.clear = target.delete = throwFrozenError;
      break;
    case 1:
      Object.freeze(target);
      let index = 0;
      for (const value of target) {
        deepFreeze(value, index, updatedValues, stack, keys);
        index += 1;
      }
      break;
    default:
      Object.freeze(target);
      Object.keys(target).forEach((name) => {
        const value = target[name];
        deepFreeze(value, name, updatedValues, stack, keys);
      });
  }
  {
    stack.pop();
    keys.pop();
  }
}
function forEach(target, iter) {
  const type = getType(target);
  if (type === 0) {
    Reflect.ownKeys(target).forEach((key) => {
      iter(key, target[key], target);
    });
  } else if (type === 1) {
    let index = 0;
    for (const entry of target) {
      iter(index, entry, target);
      index += 1;
    }
  } else {
    target.forEach((entry, index) => iter(index, entry, target));
  }
}
function handleValue(target, handledSet, options) {
  if (isDraft(target) || !isDraftable(target, options) || handledSet.has(target) || Object.isFrozen(target))
    return;
  const isSet = target instanceof Set;
  const setMap = isSet ? /* @__PURE__ */ new Map() : void 0;
  handledSet.add(target);
  forEach(target, (key, value) => {
    var _a;
    if (isDraft(value)) {
      const proxyDraft = getProxyDraft(value);
      ensureShallowCopy(proxyDraft);
      const updatedValue = ((_a = proxyDraft.assignedMap) === null || _a === void 0 ? void 0 : _a.size) || proxyDraft.operated ? proxyDraft.copy : proxyDraft.original;
      set(isSet ? setMap : target, key, updatedValue);
    } else {
      handleValue(value, handledSet, options);
    }
  });
  if (setMap) {
    const set2 = target;
    const values = Array.from(set2);
    set2.clear();
    values.forEach((value) => {
      set2.add(setMap.has(value) ? setMap.get(value) : value);
    });
  }
}
function finalizeAssigned(proxyDraft, key) {
  const copy = proxyDraft.type === 3 ? proxyDraft.setMap : proxyDraft.copy;
  if (proxyDraft.finalities.revoke.length > 1 && proxyDraft.assignedMap.get(key) && copy) {
    handleValue(get(copy, key), proxyDraft.finalities.handledSet, proxyDraft.options);
  }
}
function finalizeSetValue(target) {
  if (target.type === 3 && target.copy) {
    target.copy.clear();
    target.setMap.forEach((value) => {
      target.copy.add(getValue(value));
    });
  }
}
function finalizePatches(target, generatePatches2, patches, inversePatches) {
  const shouldFinalize = target.operated && target.assignedMap && target.assignedMap.size > 0 && !target.finalized;
  if (shouldFinalize) {
    if (patches && inversePatches) {
      const basePath = getPath(target);
      if (basePath) {
        generatePatches2(target, basePath, patches, inversePatches);
      }
    }
    target.finalized = true;
  }
}
function markFinalization(target, key, value, generatePatches2) {
  const proxyDraft = getProxyDraft(value);
  if (proxyDraft) {
    if (!proxyDraft.callbacks) {
      proxyDraft.callbacks = [];
    }
    proxyDraft.callbacks.push((patches, inversePatches) => {
      var _a;
      const copy = target.type === 3 ? target.setMap : target.copy;
      if (isEqual(get(copy, key), value)) {
        let updatedValue = proxyDraft.original;
        if (proxyDraft.copy) {
          updatedValue = proxyDraft.copy;
        }
        finalizeSetValue(target);
        finalizePatches(target, generatePatches2, patches, inversePatches);
        if (target.options.enableAutoFreeze) {
          target.options.updatedValues = (_a = target.options.updatedValues) !== null && _a !== void 0 ? _a : /* @__PURE__ */ new WeakMap();
          target.options.updatedValues.set(updatedValue, proxyDraft.original);
        }
        set(copy, key, updatedValue);
      }
    });
    if (target.options.enableAutoFreeze) {
      if (proxyDraft.finalities !== target.finalities) {
        target.options.enableAutoFreeze = false;
      }
    }
  }
  if (isDraftable(value, target.options)) {
    target.finalities.draft.push(() => {
      const copy = target.type === 3 ? target.setMap : target.copy;
      if (isEqual(get(copy, key), value)) {
        finalizeAssigned(target, key);
      }
    });
  }
}
function generateArrayPatches(proxyState, basePath, patches, inversePatches, pathAsArray) {
  let { original, assignedMap, options } = proxyState;
  let copy = proxyState.copy;
  if (copy.length < original.length) {
    [original, copy] = [copy, original];
    [patches, inversePatches] = [inversePatches, patches];
  }
  for (let index = 0; index < original.length; index += 1) {
    if (assignedMap.get(index.toString()) && copy[index] !== original[index]) {
      const _path = basePath.concat([index]);
      const path = escapePath(_path, pathAsArray);
      patches.push({
        op: Operation.Replace,
        path,
        // If it is a draft, it needs to be deep cloned, and it may also be non-draft.
        value: cloneIfNeeded(copy[index])
      });
      inversePatches.push({
        op: Operation.Replace,
        path,
        // If it is a draft, it needs to be deep cloned, and it may also be non-draft.
        value: cloneIfNeeded(original[index])
      });
    }
  }
  for (let index = original.length; index < copy.length; index += 1) {
    const _path = basePath.concat([index]);
    const path = escapePath(_path, pathAsArray);
    patches.push({
      op: Operation.Add,
      path,
      // If it is a draft, it needs to be deep cloned, and it may also be non-draft.
      value: cloneIfNeeded(copy[index])
    });
  }
  if (original.length < copy.length) {
    const { arrayLengthAssignment = true } = options.enablePatches;
    if (arrayLengthAssignment) {
      const _path = basePath.concat(["length"]);
      const path = escapePath(_path, pathAsArray);
      inversePatches.push({
        op: Operation.Replace,
        path,
        value: original.length
      });
    } else {
      for (let index = copy.length; original.length < index; index -= 1) {
        const _path = basePath.concat([index - 1]);
        const path = escapePath(_path, pathAsArray);
        inversePatches.push({
          op: Operation.Remove,
          path
        });
      }
    }
  }
}
function generatePatchesFromAssigned({ original, copy, assignedMap }, basePath, patches, inversePatches, pathAsArray) {
  assignedMap.forEach((assignedValue, key) => {
    const originalValue = get(original, key);
    const value = cloneIfNeeded(get(copy, key));
    const op = !assignedValue ? Operation.Remove : has(original, key) ? Operation.Replace : Operation.Add;
    if (isEqual(originalValue, value) && op === Operation.Replace)
      return;
    const _path = basePath.concat(key);
    const path = escapePath(_path, pathAsArray);
    patches.push(op === Operation.Remove ? { op, path } : { op, path, value });
    inversePatches.push(op === Operation.Add ? { op: Operation.Remove, path } : op === Operation.Remove ? { op: Operation.Add, path, value: originalValue } : { op: Operation.Replace, path, value: originalValue });
  });
}
function generateSetPatches({ original, copy }, basePath, patches, inversePatches, pathAsArray) {
  let index = 0;
  original.forEach((value) => {
    if (!copy.has(value)) {
      const _path = basePath.concat([index]);
      const path = escapePath(_path, pathAsArray);
      patches.push({
        op: Operation.Remove,
        path,
        value
      });
      inversePatches.unshift({
        op: Operation.Add,
        path,
        value
      });
    }
    index += 1;
  });
  index = 0;
  copy.forEach((value) => {
    if (!original.has(value)) {
      const _path = basePath.concat([index]);
      const path = escapePath(_path, pathAsArray);
      patches.push({
        op: Operation.Add,
        path,
        value
      });
      inversePatches.unshift({
        op: Operation.Remove,
        path,
        value
      });
    }
    index += 1;
  });
}
function generatePatches(proxyState, basePath, patches, inversePatches) {
  const { pathAsArray = true } = proxyState.options.enablePatches;
  switch (proxyState.type) {
    case 0:
    case 2:
      return generatePatchesFromAssigned(proxyState, basePath, patches, inversePatches, pathAsArray);
    case 1:
      return generateArrayPatches(proxyState, basePath, patches, inversePatches, pathAsArray);
    case 3:
      return generateSetPatches(proxyState, basePath, patches, inversePatches, pathAsArray);
  }
}
var readable = false;
var checkReadable = (value, options, ignoreCheckDraftable = false) => {
  if (typeof value === "object" && value !== null && (!isDraftable(value, options) || ignoreCheckDraftable) && !readable) {
    throw new Error(`Strict mode: Mutable data cannot be accessed directly, please use 'unsafe(callback)' wrap.`);
  }
};
var mapHandler = {
  get size() {
    const current2 = latest(getProxyDraft(this));
    return current2.size;
  },
  has(key) {
    return latest(getProxyDraft(this)).has(key);
  },
  set(key, value) {
    const target = getProxyDraft(this);
    const source = latest(target);
    if (!source.has(key) || !isEqual(source.get(key), value)) {
      ensureShallowCopy(target);
      markChanged(target);
      target.assignedMap.set(key, true);
      target.copy.set(key, value);
      markFinalization(target, key, value, generatePatches);
    }
    return this;
  },
  delete(key) {
    if (!this.has(key)) {
      return false;
    }
    const target = getProxyDraft(this);
    ensureShallowCopy(target);
    markChanged(target);
    if (target.original.has(key)) {
      target.assignedMap.set(key, false);
    } else {
      target.assignedMap.delete(key);
    }
    target.copy.delete(key);
    return true;
  },
  clear() {
    const target = getProxyDraft(this);
    if (!this.size)
      return;
    ensureShallowCopy(target);
    markChanged(target);
    target.assignedMap = /* @__PURE__ */ new Map();
    for (const [key] of target.original) {
      target.assignedMap.set(key, false);
    }
    target.copy.clear();
  },
  forEach(callback, thisArg) {
    const target = getProxyDraft(this);
    latest(target).forEach((_value, _key) => {
      callback.call(thisArg, this.get(_key), _key, this);
    });
  },
  get(key) {
    var _a, _b;
    const target = getProxyDraft(this);
    const value = latest(target).get(key);
    const mutable = ((_b = (_a = target.options).mark) === null || _b === void 0 ? void 0 : _b.call(_a, value, dataTypes)) === dataTypes.mutable;
    if (target.options.strict) {
      checkReadable(value, target.options, mutable);
    }
    if (mutable) {
      return value;
    }
    if (target.finalized || !isDraftable(value, target.options)) {
      return value;
    }
    if (value !== target.original.get(key)) {
      return value;
    }
    const draft = internal.createDraft({
      original: value,
      parentDraft: target,
      key,
      finalities: target.finalities,
      options: target.options
    });
    ensureShallowCopy(target);
    target.copy.set(key, draft);
    return draft;
  },
  keys() {
    return latest(getProxyDraft(this)).keys();
  },
  values() {
    const iterator = this.keys();
    return {
      [iteratorSymbol]: () => this.values(),
      next: () => {
        const result = iterator.next();
        if (result.done)
          return result;
        const value = this.get(result.value);
        return {
          done: false,
          value
        };
      }
    };
  },
  entries() {
    const iterator = this.keys();
    return {
      [iteratorSymbol]: () => this.entries(),
      next: () => {
        const result = iterator.next();
        if (result.done)
          return result;
        const value = this.get(result.value);
        return {
          done: false,
          value: [result.value, value]
        };
      }
    };
  },
  [iteratorSymbol]() {
    return this.entries();
  }
};
var mapHandlerKeys = Reflect.ownKeys(mapHandler);
var getNextIterator = (target, iterator, { isValuesIterator }) => () => {
  var _a, _b;
  const result = iterator.next();
  if (result.done)
    return result;
  const key = result.value;
  let value = target.setMap.get(key);
  const currentDraft = getProxyDraft(value);
  const mutable = ((_b = (_a = target.options).mark) === null || _b === void 0 ? void 0 : _b.call(_a, value, dataTypes)) === dataTypes.mutable;
  if (target.options.strict) {
    checkReadable(key, target.options, mutable);
  }
  if (!mutable && !currentDraft && isDraftable(key, target.options) && !target.finalized && target.original.has(key)) {
    const proxy = internal.createDraft({
      original: key,
      parentDraft: target,
      key,
      finalities: target.finalities,
      options: target.options
    });
    target.setMap.set(key, proxy);
    value = proxy;
  } else if (currentDraft) {
    value = currentDraft.proxy;
  }
  return {
    done: false,
    value: isValuesIterator ? value : [value, value]
  };
};
var setHandler = {
  get size() {
    const target = getProxyDraft(this);
    return target.setMap.size;
  },
  has(value) {
    const target = getProxyDraft(this);
    if (target.setMap.has(value))
      return true;
    ensureShallowCopy(target);
    const valueProxyDraft = getProxyDraft(value);
    if (valueProxyDraft && target.setMap.has(valueProxyDraft.original))
      return true;
    return false;
  },
  add(value) {
    const target = getProxyDraft(this);
    if (!this.has(value)) {
      ensureShallowCopy(target);
      markChanged(target);
      target.assignedMap.set(value, true);
      target.setMap.set(value, value);
      markFinalization(target, value, value, generatePatches);
    }
    return this;
  },
  delete(value) {
    if (!this.has(value)) {
      return false;
    }
    const target = getProxyDraft(this);
    ensureShallowCopy(target);
    markChanged(target);
    const valueProxyDraft = getProxyDraft(value);
    if (valueProxyDraft && target.setMap.has(valueProxyDraft.original)) {
      target.assignedMap.set(valueProxyDraft.original, false);
      return target.setMap.delete(valueProxyDraft.original);
    }
    if (!valueProxyDraft && target.setMap.has(value)) {
      target.assignedMap.set(value, false);
    } else {
      target.assignedMap.delete(value);
    }
    return target.setMap.delete(value);
  },
  clear() {
    if (!this.size)
      return;
    const target = getProxyDraft(this);
    ensureShallowCopy(target);
    markChanged(target);
    for (const value of target.original) {
      target.assignedMap.set(value, false);
    }
    target.setMap.clear();
  },
  values() {
    const target = getProxyDraft(this);
    ensureShallowCopy(target);
    const iterator = target.setMap.keys();
    return {
      [Symbol.iterator]: () => this.values(),
      next: getNextIterator(target, iterator, { isValuesIterator: true })
    };
  },
  entries() {
    const target = getProxyDraft(this);
    ensureShallowCopy(target);
    const iterator = target.setMap.keys();
    return {
      [Symbol.iterator]: () => this.entries(),
      next: getNextIterator(target, iterator, {
        isValuesIterator: false
      })
    };
  },
  keys() {
    return this.values();
  },
  [iteratorSymbol]() {
    return this.values();
  },
  forEach(callback, thisArg) {
    const iterator = this.values();
    let result = iterator.next();
    while (!result.done) {
      callback.call(thisArg, result.value, result.value, this);
      result = iterator.next();
    }
  }
};
var setHandlerKeys = Reflect.ownKeys(setHandler);
var draftsCache = /* @__PURE__ */ new WeakSet();
var proxyHandler = {
  get(target, key, receiver) {
    var _a, _b;
    const copy = (_a = target.copy) === null || _a === void 0 ? void 0 : _a[key];
    if (copy && draftsCache.has(copy)) {
      return copy;
    }
    if (key === PROXY_DRAFT)
      return target;
    let markResult;
    if (target.options.mark) {
      const value2 = key === "size" && (target.original instanceof Map || target.original instanceof Set) ? Reflect.get(target.original, key) : Reflect.get(target.original, key, receiver);
      markResult = target.options.mark(value2, dataTypes);
      if (markResult === dataTypes.mutable) {
        if (target.options.strict) {
          checkReadable(value2, target.options, true);
        }
        return value2;
      }
    }
    const source = latest(target);
    if (source instanceof Map && mapHandlerKeys.includes(key)) {
      if (key === "size") {
        return Object.getOwnPropertyDescriptor(mapHandler, "size").get.call(target.proxy);
      }
      const handle = mapHandler[key];
      if (handle) {
        return handle.bind(target.proxy);
      }
    }
    if (source instanceof Set && setHandlerKeys.includes(key)) {
      if (key === "size") {
        return Object.getOwnPropertyDescriptor(setHandler, "size").get.call(target.proxy);
      }
      const handle = setHandler[key];
      if (handle) {
        return handle.bind(target.proxy);
      }
    }
    if (!has(source, key)) {
      const desc = getDescriptor(source, key);
      return desc ? `value` in desc ? desc.value : (
        // !case: support for getter
        (_b = desc.get) === null || _b === void 0 ? void 0 : _b.call(target.proxy)
      ) : void 0;
    }
    const value = source[key];
    if (target.options.strict) {
      checkReadable(value, target.options);
    }
    if (target.finalized || !isDraftable(value, target.options)) {
      return value;
    }
    if (value === peek(target.original, key)) {
      ensureShallowCopy(target);
      target.copy[key] = createDraft({
        original: target.original[key],
        parentDraft: target,
        key: target.type === 1 ? Number(key) : key,
        finalities: target.finalities,
        options: target.options
      });
      if (typeof markResult === "function") {
        const subProxyDraft = getProxyDraft(target.copy[key]);
        ensureShallowCopy(subProxyDraft);
        markChanged(subProxyDraft);
        return subProxyDraft.copy;
      }
      return target.copy[key];
    }
    return value;
  },
  set(target, key, value) {
    var _a;
    if (target.type === 3 || target.type === 2) {
      throw new Error(`Map/Set draft does not support any property assignment.`);
    }
    let _key;
    if (target.type === 1 && key !== "length" && !(Number.isInteger(_key = Number(key)) && _key >= 0 && (key === 0 || _key === 0 || String(_key) === String(key)))) {
      throw new Error(`Only supports setting array indices and the 'length' property.`);
    }
    const desc = getDescriptor(latest(target), key);
    if (desc === null || desc === void 0 ? void 0 : desc.set) {
      desc.set.call(target.proxy, value);
      return true;
    }
    const current2 = peek(latest(target), key);
    const currentProxyDraft = getProxyDraft(current2);
    if (currentProxyDraft && isEqual(currentProxyDraft.original, value)) {
      target.copy[key] = value;
      target.assignedMap = (_a = target.assignedMap) !== null && _a !== void 0 ? _a : /* @__PURE__ */ new Map();
      target.assignedMap.set(key, false);
      return true;
    }
    if (isEqual(value, current2) && (value !== void 0 || has(target.original, key)))
      return true;
    ensureShallowCopy(target);
    markChanged(target);
    if (has(target.original, key) && isEqual(value, target.original[key])) {
      target.assignedMap.delete(key);
    } else {
      target.assignedMap.set(key, true);
    }
    target.copy[key] = value;
    markFinalization(target, key, value, generatePatches);
    return true;
  },
  has(target, key) {
    return key in latest(target);
  },
  ownKeys(target) {
    return Reflect.ownKeys(latest(target));
  },
  getOwnPropertyDescriptor(target, key) {
    const source = latest(target);
    const descriptor = Reflect.getOwnPropertyDescriptor(source, key);
    if (!descriptor)
      return descriptor;
    return {
      writable: true,
      configurable: target.type !== 1 || key !== "length",
      enumerable: descriptor.enumerable,
      value: source[key]
    };
  },
  getPrototypeOf(target) {
    return Reflect.getPrototypeOf(target.original);
  },
  setPrototypeOf() {
    throw new Error(`Cannot call 'setPrototypeOf()' on drafts`);
  },
  defineProperty() {
    throw new Error(`Cannot call 'defineProperty()' on drafts`);
  },
  deleteProperty(target, key) {
    var _a;
    if (target.type === 1) {
      return proxyHandler.set.call(this, target, key, void 0, target.proxy);
    }
    if (peek(target.original, key) !== void 0 || key in target.original) {
      ensureShallowCopy(target);
      markChanged(target);
      target.assignedMap.set(key, false);
    } else {
      target.assignedMap = (_a = target.assignedMap) !== null && _a !== void 0 ? _a : /* @__PURE__ */ new Map();
      target.assignedMap.delete(key);
    }
    if (target.copy)
      delete target.copy[key];
    return true;
  }
};
function createDraft(createDraftOptions) {
  const { original, parentDraft, key, finalities, options } = createDraftOptions;
  const type = getType(original);
  const proxyDraft = {
    type,
    finalized: false,
    parent: parentDraft,
    original,
    copy: null,
    proxy: null,
    finalities,
    options,
    // Mapping of draft Set items to their corresponding draft values.
    setMap: type === 3 ? new Map(original.entries()) : void 0
  };
  if (key || "key" in createDraftOptions) {
    proxyDraft.key = key;
  }
  const { proxy, revoke } = Proxy.revocable(type === 1 ? Object.assign([], proxyDraft) : proxyDraft, proxyHandler);
  finalities.revoke.push(revoke);
  draftsCache.add(proxy);
  proxyDraft.proxy = proxy;
  if (parentDraft) {
    const target = parentDraft;
    target.finalities.draft.push((patches, inversePatches) => {
      var _a, _b;
      const oldProxyDraft = getProxyDraft(proxy);
      let copy = target.type === 3 ? target.setMap : target.copy;
      const draft = get(copy, key);
      const proxyDraft2 = getProxyDraft(draft);
      if (proxyDraft2) {
        let updatedValue = proxyDraft2.original;
        if (proxyDraft2.operated) {
          updatedValue = getValue(draft);
        }
        finalizeSetValue(proxyDraft2);
        finalizePatches(proxyDraft2, generatePatches, patches, inversePatches);
        if (target.options.enableAutoFreeze) {
          target.options.updatedValues = (_a = target.options.updatedValues) !== null && _a !== void 0 ? _a : /* @__PURE__ */ new WeakMap();
          target.options.updatedValues.set(updatedValue, proxyDraft2.original);
        }
        set(copy, key, updatedValue);
      }
      (_b = oldProxyDraft.callbacks) === null || _b === void 0 ? void 0 : _b.forEach((callback) => {
        callback(patches, inversePatches);
      });
    });
  } else {
    const target = getProxyDraft(proxy);
    target.finalities.draft.push((patches, inversePatches) => {
      finalizeSetValue(target);
      finalizePatches(target, generatePatches, patches, inversePatches);
    });
  }
  return proxy;
}
internal.createDraft = createDraft;
function finalizeDraft(result, returnedValue, patches, inversePatches, enableAutoFreeze) {
  var _a;
  const proxyDraft = getProxyDraft(result);
  const original = (_a = proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.original) !== null && _a !== void 0 ? _a : result;
  const hasReturnedValue = !!returnedValue.length;
  if (proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.operated) {
    while (proxyDraft.finalities.draft.length > 0) {
      const finalize = proxyDraft.finalities.draft.pop();
      finalize(patches, inversePatches);
    }
  }
  const state = hasReturnedValue ? returnedValue[0] : proxyDraft ? proxyDraft.operated ? proxyDraft.copy : proxyDraft.original : result;
  if (proxyDraft)
    revokeProxy(proxyDraft);
  if (enableAutoFreeze) {
    deepFreeze(state, state, proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.options.updatedValues);
  }
  return [
    state,
    patches && hasReturnedValue ? [{ op: Operation.Replace, path: [], value: returnedValue[0] }] : patches,
    inversePatches && hasReturnedValue ? [{ op: Operation.Replace, path: [], value: original }] : inversePatches
  ];
}
function draftify(baseState, options) {
  var _a;
  const finalities = {
    draft: [],
    revoke: [],
    handledSet: /* @__PURE__ */ new WeakSet()
  };
  let patches;
  let inversePatches;
  if (options.enablePatches) {
    patches = [];
    inversePatches = [];
  }
  const isMutable = ((_a = options.mark) === null || _a === void 0 ? void 0 : _a.call(options, baseState, dataTypes)) === dataTypes.mutable || !isDraftable(baseState, options);
  const draft = isMutable ? baseState : createDraft({
    original: baseState,
    parentDraft: null,
    finalities,
    options
  });
  return [
    draft,
    (returnedValue = []) => {
      const [finalizedState, finalizedPatches, finalizedInversePatches] = finalizeDraft(draft, returnedValue, patches, inversePatches, options.enableAutoFreeze);
      return options.enablePatches ? [finalizedState, finalizedPatches, finalizedInversePatches] : finalizedState;
    }
  ];
}
function handleReturnValue(options) {
  const { rootDraft, value, useRawReturn = false, isRoot = true } = options;
  forEach(value, (key, item, source) => {
    const proxyDraft = getProxyDraft(item);
    if (proxyDraft && rootDraft && proxyDraft.finalities === rootDraft.finalities) {
      options.isContainDraft = true;
      const currentValue = proxyDraft.original;
      if (source instanceof Set) {
        const arr = Array.from(source);
        source.clear();
        arr.forEach((_item) => source.add(key === _item ? currentValue : _item));
      } else {
        set(source, key, currentValue);
      }
    } else if (typeof item === "object" && item !== null) {
      options.value = item;
      options.isRoot = false;
      handleReturnValue(options);
    }
  });
  if (isRoot) {
    if (!options.isContainDraft)
      console.warn(`The return value does not contain any draft, please use 'rawReturn()' to wrap the return value to improve performance.`);
    if (useRawReturn) {
      console.warn(`The return value contains drafts, please don't use 'rawReturn()' to wrap the return value.`);
    }
  }
}
function getCurrent(target) {
  const proxyDraft = getProxyDraft(target);
  if (!isDraftable(target, proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.options))
    return target;
  const type = getType(target);
  if (proxyDraft && !proxyDraft.operated)
    return proxyDraft.original;
  let currentValue;
  function ensureShallowCopy2() {
    currentValue = type === 2 ? new Map(target) : type === 3 ? Array.from(proxyDraft.setMap.values()) : shallowCopy(target, proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.options);
  }
  if (proxyDraft) {
    proxyDraft.finalized = true;
    try {
      ensureShallowCopy2();
    } finally {
      proxyDraft.finalized = false;
    }
  } else {
    currentValue = target;
  }
  forEach(currentValue, (key, value) => {
    if (proxyDraft && isEqual(get(proxyDraft.original, key), value))
      return;
    const newValue = getCurrent(value);
    if (newValue !== value) {
      if (currentValue === target)
        ensureShallowCopy2();
      set(currentValue, key, newValue);
    }
  });
  return type === 3 ? new Set(currentValue) : currentValue;
}
function current(target) {
  if (!isDraft(target)) {
    throw new Error(`current() is only used for Draft, parameter: ${target}`);
  }
  return getCurrent(target);
}
var makeCreator = (arg) => {
  if (arg !== void 0 && Object.prototype.toString.call(arg) !== "[object Object]") {
    throw new Error(`Invalid options: ${String(arg)}, 'options' should be an object.`);
  }
  return function create2(arg0, arg1, arg2) {
    var _a, _b, _c;
    if (typeof arg0 === "function" && typeof arg1 !== "function") {
      return function(base2, ...args) {
        return create2(base2, (draft2) => arg0.call(this, draft2, ...args), arg1);
      };
    }
    const base = arg0;
    const mutate = arg1;
    let options = arg2;
    if (typeof arg1 !== "function") {
      options = arg1;
    }
    if (options !== void 0 && Object.prototype.toString.call(options) !== "[object Object]") {
      throw new Error(`Invalid options: ${options}, 'options' should be an object.`);
    }
    options = Object.assign(Object.assign({}, arg), options);
    const state = isDraft(base) ? current(base) : base;
    const mark = Array.isArray(options.mark) ? (value, types) => {
      for (const mark2 of options.mark) {
        if (typeof mark2 !== "function") {
          throw new Error(`Invalid mark: ${mark2}, 'mark' should be a function.`);
        }
        const result2 = mark2(value, types);
        if (result2) {
          return result2;
        }
      }
      return;
    } : options.mark;
    const enablePatches = (_a = options.enablePatches) !== null && _a !== void 0 ? _a : false;
    const strict = (_b = options.strict) !== null && _b !== void 0 ? _b : false;
    const enableAutoFreeze = (_c = options.enableAutoFreeze) !== null && _c !== void 0 ? _c : false;
    const _options = {
      enableAutoFreeze,
      mark,
      strict,
      enablePatches
    };
    if (!isDraftable(state, _options) && typeof state === "object" && state !== null) {
      throw new Error(`Invalid base state: create() only supports plain objects, arrays, Set, Map or using mark() to mark the state as immutable.`);
    }
    const [draft, finalize] = draftify(state, _options);
    if (typeof arg1 !== "function") {
      if (!isDraftable(state, _options)) {
        throw new Error(`Invalid base state: create() only supports plain objects, arrays, Set, Map or using mark() to mark the state as immutable.`);
      }
      return [draft, finalize];
    }
    let result;
    try {
      result = mutate(draft);
    } catch (error) {
      revokeProxy(getProxyDraft(draft));
      throw error;
    }
    const returnValue = (value) => {
      const proxyDraft = getProxyDraft(draft);
      if (!isDraft(value)) {
        if (value !== void 0 && !isEqual(value, draft) && (proxyDraft === null || proxyDraft === void 0 ? void 0 : proxyDraft.operated)) {
          throw new Error(`Either the value is returned as a new non-draft value, or only the draft is modified without returning any value.`);
        }
        const rawReturnValue = value === null || value === void 0 ? void 0 : value[RAW_RETURN_SYMBOL];
        if (rawReturnValue) {
          const _value = rawReturnValue[0];
          if (_options.strict && typeof value === "object" && value !== null) {
            handleReturnValue({
              rootDraft: proxyDraft,
              value,
              useRawReturn: true
            });
          }
          return finalize([_value]);
        }
        if (value !== void 0) {
          if (typeof value === "object" && value !== null) {
            handleReturnValue({ rootDraft: proxyDraft, value });
          }
          return finalize([value]);
        }
      }
      if (value === draft || value === void 0) {
        return finalize([]);
      }
      const returnedProxyDraft = getProxyDraft(value);
      if (_options === returnedProxyDraft.options) {
        if (returnedProxyDraft.operated) {
          throw new Error(`Cannot return a modified child draft.`);
        }
        return finalize([current(value)]);
      }
      return finalize([value]);
    };
    if (result instanceof Promise) {
      return result.then(returnValue, (error) => {
        revokeProxy(getProxyDraft(draft));
        throw error;
      });
    }
    return returnValue(result);
  };
};
var create = makeCreator();
var constructorString = Object.prototype.constructor.toString();

// ../node_modules/@instantdb/core/dist/module/utils/object.js
function areObjectKeysEqual(a, b) {
  const ak = Object.keys(a);
  const bk = Object.keys(b);
  return ak.length === bk.length && Object.keys(a).every((k) => b.hasOwnProperty(k));
}
function areObjectsShallowEqual(obj1, obj2) {
  return Object.keys(obj1).length === Object.keys(obj2).length && Object.keys(obj1).every((key) => obj2.hasOwnProperty(key) && obj1[key] === obj2[key]);
}
function areObjectsDeepEqual(obj1, obj2) {
  if (typeof obj1 !== "object" || typeof obj2 !== "object" || obj1 === null || obj2 === null) {
    return obj1 === obj2;
  }
  if (!areObjectKeysEqual(obj1, obj2)) {
    return false;
  }
  return Object.keys(obj1).every((key) => areObjectsDeepEqual(obj1[key], obj2[key]));
}
function immutableDeepMerge(target, source) {
  if (!isObject(target) || !isObject(source)) {
    return source;
  }
  const result = {};
  for (const key of Object.keys(target)) {
    if (source[key] === null)
      continue;
    result[key] = target[key];
  }
  for (const key of Object.keys(source)) {
    if (source[key] === null)
      continue;
    const areBothObjects = isObject(target[key]) && isObject(source[key]);
    result[key] = areBothObjects ? immutableDeepMerge(target[key], source[key]) : source[key];
  }
  return result;
}
function immutableDeepReplace(target, replaceValue, replacementValue) {
  if (!isObject(target)) {
    return target;
  }
  const result = {};
  for (const [key, value] of Object.entries(target)) {
    result[key] = isObject(value) ? immutableDeepReplace(value, replaceValue, replacementValue) : value === replaceValue ? replacementValue : value;
  }
  return result;
}
function isObject(val) {
  return typeof val === "object" && val !== null && !Array.isArray(val);
}

// ../node_modules/@instantdb/core/dist/module/store.js
function hasEA(attr) {
  return attr["cardinality"] === "one";
}
function isRef(attr) {
  return attr["value-type"] === "ref";
}
function isBlob(attr) {
  return attr["value-type"] === "blob";
}
function getAttr(attrs, attrId) {
  return attrs[attrId];
}
function getInMap(obj, path) {
  return path.reduce((acc, key) => acc && acc.get(key), obj);
}
function deleteInMap(m, path) {
  if (path.length === 0)
    throw new Error("path must have at least one element");
  if (path.length === 1) {
    m.delete(path[0]);
    return;
  }
  const [head, ...tail] = path;
  if (!m.has(head))
    return;
  deleteInMap(m.get(head), tail);
}
function setInMap(m, path, value) {
  if (path.length === 0)
    throw new Error("path must have at least one element");
  if (path.length === 1) {
    m.set(path[0], value);
    return;
  }
  const [head, ...tail] = path;
  let nextM = m.get(head);
  if (!nextM) {
    nextM = /* @__PURE__ */ new Map();
    m.set(head, nextM);
  }
  setInMap(nextM, tail, value);
}
function createIndexMap(attrs, triples) {
  const eav = /* @__PURE__ */ new Map();
  const aev = /* @__PURE__ */ new Map();
  const vae = /* @__PURE__ */ new Map();
  for (const triple of triples) {
    const [eid, aid, v, t] = triple;
    const attr = getAttr(attrs, aid);
    if (!attr) {
      console.warn("no such attr", eid, attrs);
      continue;
    }
    if (isRef(attr)) {
      setInMap(vae, [v, aid, eid], triple);
    }
    setInMap(eav, [eid, aid, v], triple);
    setInMap(aev, [aid, eid, v], triple);
  }
  return { eav, aev, vae };
}
function blobAttrs({ attrs }, etype) {
  return Object.values(attrs).filter((attr) => isBlob(attr) && attr["forward-identity"][1] === etype);
}
function getAsObject(store, attrs, e) {
  var _a;
  const obj = {};
  for (const attr of attrs) {
    const aMap = (_a = store.eav.get(e)) === null || _a === void 0 ? void 0 : _a.get(attr.id);
    const vs = allMapValues(aMap, 1);
    for (const v of vs) {
      obj[attr["forward-identity"][2]] = v[2];
    }
  }
  return obj;
}
function toJSON(store) {
  return {
    __type: store.__type,
    attrs: store.attrs,
    triples: allMapValues(store.eav, 3),
    cardinalityInference: store.cardinalityInference,
    linkIndex: store.linkIndex
  };
}
function fromJSON(storeJSON) {
  return createStore(storeJSON.attrs, storeJSON.triples, storeJSON.cardinalityInference, storeJSON.linkIndex);
}
function createStore(attrs, triples, enableCardinalityInference, linkIndex) {
  const store = createIndexMap(attrs, triples);
  store.attrs = attrs;
  store.cardinalityInference = enableCardinalityInference;
  store.linkIndex = linkIndex;
  store.__type = "store";
  return store;
}
function resolveLookupRefs(store, triple) {
  var _a, _b;
  let eid;
  if (Array.isArray(triple[0])) {
    const [a, v] = triple[0];
    const eMaps = store.aev.get(a);
    if (!eMaps) {
      return null;
    }
    const triples = allMapValues(eMaps, 2);
    eid = (_a = triples.find((x) => x[2] === v)) === null || _a === void 0 ? void 0 : _a[0];
  } else {
    eid = triple[0];
  }
  if (!eid) {
    return null;
  }
  const lookupV = triple[2];
  if (Array.isArray(lookupV) && lookupV.length === 2 && store.aev.get(lookupV[0])) {
    const [a, v] = lookupV;
    const eMaps = store.aev.get(a);
    if (!eMaps) {
      return null;
    }
    const triples = allMapValues(eMaps, 2);
    const value = (_b = triples.find((x) => x[2] === v)) === null || _b === void 0 ? void 0 : _b[0];
    if (!value) {
      return null;
    }
    const [_e, aid, _v, ...rest] = triple;
    return [eid, aid, value, ...rest];
  } else {
    const [_, ...rest] = triple;
    return [eid, ...rest];
  }
}
function retractTriple(store, rawTriple) {
  const triple = resolveLookupRefs(store, rawTriple);
  if (!triple) {
    return;
  }
  const [eid, aid, v] = triple;
  const attr = getAttr(store.attrs, aid);
  if (!attr) {
    return;
  }
  deleteInMap(store.eav, [eid, aid, v]);
  deleteInMap(store.aev, [aid, eid, v]);
  if (isRef(attr)) {
    deleteInMap(store.vae, [v, aid, eid]);
  }
}
var _seed = 0;
function getCreatedAt(store, attr, triple) {
  const [eid, aid, v] = triple;
  let createdAt;
  const t = getInMap(store.ea, [eid, aid, v]);
  if (t) {
    createdAt = t[3];
  }
  return createdAt || Date.now() * 10 + _seed++;
}
function addTriple(store, rawTriple) {
  var _a;
  const triple = resolveLookupRefs(store, rawTriple);
  if (!triple) {
    return;
  }
  const [eid, aid, v] = triple;
  const attr = getAttr(store.attrs, aid);
  if (!attr) {
    return;
  }
  const existingTriple = getInMap(store.eav, [eid, aid, v]);
  const t = (_a = existingTriple === null || existingTriple === void 0 ? void 0 : existingTriple[3]) !== null && _a !== void 0 ? _a : getCreatedAt(store, attr, triple);
  const enhancedTriple = [eid, aid, v, t];
  if (hasEA(attr)) {
    setInMap(store.eav, [eid, aid], /* @__PURE__ */ new Map([[v, enhancedTriple]]));
    setInMap(store.aev, [aid, eid], /* @__PURE__ */ new Map([[v, enhancedTriple]]));
  } else {
    setInMap(store.eav, [eid, aid, v], enhancedTriple);
    setInMap(store.aev, [aid, eid, v], enhancedTriple);
  }
  if (isRef(attr)) {
    setInMap(store.vae, [v, aid, eid], enhancedTriple);
  }
}
function mergeTriple(store, rawTriple) {
  var _a;
  const triple = resolveLookupRefs(store, rawTriple);
  if (!triple) {
    return;
  }
  const [eid, aid, update] = triple;
  const attr = getAttr(store.attrs, aid);
  if (!attr)
    return;
  if (!isBlob(attr))
    throw new Error("merge operation is not supported for links");
  const eavValuesMap = getInMap(store.eav, [eid, aid]);
  if (!eavValuesMap)
    return;
  const currentTriple = (_a = eavValuesMap.values().next()) === null || _a === void 0 ? void 0 : _a.value;
  if (!currentTriple)
    return;
  const currentValue = currentTriple[2];
  const updatedValue = immutableDeepMerge(currentValue, update);
  const enhancedTriple = [
    eid,
    aid,
    updatedValue,
    getCreatedAt(store, attr, currentTriple)
  ];
  setInMap(store.eav, [eid, aid], /* @__PURE__ */ new Map([[updatedValue, enhancedTriple]]));
}
function deleteEntity(store, args) {
  var _a, _b;
  const [lookup2, etype] = args;
  const triple = resolveLookupRefs(store, [lookup2]);
  if (!triple) {
    return;
  }
  const [id2] = triple;
  const eMap = store.eav.get(id2);
  if (eMap) {
    for (const a of eMap.keys()) {
      const attr = store.attrs[a];
      if (
        // Fall back to deleting everything if we've rehydrated tx-steps from
        // the store that didn't set `etype` in deleteEntity
        !etype || // If we don't know about the attr, let's just get rid of it
        !attr || // Make sure it matches the etype
        ((_a = attr["forward-identity"]) === null || _a === void 0 ? void 0 : _a[1]) === etype
      ) {
        deleteInMap(store.aev, [a, id2]);
        deleteInMap(store.eav, [id2, a]);
      }
    }
    if (eMap.size === 0) {
      deleteInMap(store.eav, [id2]);
    }
  }
  const vaeTriples = store.vae.get(id2) && allMapValues(store.vae.get(id2), 2);
  if (vaeTriples) {
    vaeTriples.forEach((triple2) => {
      var _a2;
      const [e, a, v] = triple2;
      const attr = store.attrs[a];
      if (!etype || !attr || ((_a2 = attr["reverse-identity"]) === null || _a2 === void 0 ? void 0 : _a2[1]) === etype) {
        deleteInMap(store.eav, [e, a, v]);
        deleteInMap(store.aev, [a, e, v]);
        deleteInMap(store.vae, [v, a, e]);
      }
    });
  }
  if (((_b = store.vae.get(id2)) === null || _b === void 0 ? void 0 : _b.size) === 0) {
    deleteInMap(store.vae, [id2]);
  }
}
function resetIndexMap(store, newTriples) {
  const newIndexMap = createIndexMap(store.attrs, newTriples);
  Object.keys(newIndexMap).forEach((key) => {
    store[key] = newIndexMap[key];
  });
}
function addAttr(store, [attr]) {
  store.attrs[attr.id] = attr;
}
function getAllTriples(store) {
  return allMapValues(store.eav, 3);
}
function deleteAttr(store, [id2]) {
  if (!store.attrs[id2])
    return;
  const newTriples = getAllTriples(store).filter(([_, aid]) => aid !== id2);
  delete store.attrs[id2];
  resetIndexMap(store, newTriples);
}
function updateAttr(store, [partialAttr]) {
  const attr = store.attrs[partialAttr.id];
  if (!attr)
    return;
  store.attrs[partialAttr.id] = Object.assign(Object.assign({}, attr), partialAttr);
  resetIndexMap(store, getAllTriples(store));
}
function applyTxStep(store, txStep) {
  const [action, ...args] = txStep;
  switch (action) {
    case "add-triple":
      addTriple(store, args);
      break;
    case "deep-merge-triple":
      mergeTriple(store, args);
      break;
    case "retract-triple":
      retractTriple(store, args);
      break;
    case "delete-entity":
      deleteEntity(store, args);
      break;
    case "add-attr":
      addAttr(store, args);
      break;
    case "delete-attr":
      deleteAttr(store, args);
      break;
    case "update-attr":
      updateAttr(store, args);
      break;
    default:
      throw new Error(`unhandled transaction action: ${action}`);
  }
}
function allMapValues(m, level, res = []) {
  if (!m) {
    return res;
  }
  if (level === 0) {
    return res;
  }
  if (level === 1) {
    for (const v of m.values()) {
      res.push(v);
    }
    return res;
  }
  for (const v of m.values()) {
    allMapValues(v, level - 1, res);
  }
  return res;
}
function triplesByValue(m, v) {
  const res = [];
  const values = v.in ? v.in : [v];
  for (const value of values) {
    const triple = m.get(value);
    if (triple) {
      res.push(triple);
    }
  }
  return res;
}
function whichIdx(e, a, v) {
  let res = "";
  if (e !== void 0) {
    res += "e";
  }
  if (a !== void 0) {
    res += "a";
  }
  if (v !== void 0) {
    res += "v";
  }
  return res;
}
function getTriples(store, [e, a, v]) {
  var _a, _b;
  const idx = whichIdx(e, a, v);
  switch (idx) {
    case "e": {
      const eMap = store.eav.get(e);
      return allMapValues(eMap, 2);
    }
    case "ea": {
      const aMap = (_a = store.eav.get(e)) === null || _a === void 0 ? void 0 : _a.get(a);
      return allMapValues(aMap, 1);
    }
    case "eav": {
      const aMap = (_b = store.eav.get(e)) === null || _b === void 0 ? void 0 : _b.get(a);
      if (!aMap) {
        return [];
      }
      return triplesByValue(aMap, v);
    }
    case "ev": {
      const eMap = store.eav.get(e);
      if (!eMap) {
        return [];
      }
      const res = [];
      for (const aMap of eMap.values()) {
        res.push(...triplesByValue(aMap, v));
      }
      return res;
    }
    case "a": {
      const aMap = store.aev.get(a);
      return allMapValues(aMap, 2);
    }
    case "av": {
      const aMap = store.aev.get(a);
      if (!aMap) {
        return [];
      }
      const res = [];
      for (const eMap of aMap.values()) {
        res.push(...triplesByValue(eMap, v));
      }
      return res;
    }
    case "v": {
      const res = [];
      for (const eMap of store.eav.values()) {
        for (const aMap of eMap.values()) {
          res.push(...triplesByValue(aMap, v));
        }
      }
    }
    default: {
      return allMapValues(store.eav, 3);
    }
  }
}
function transact(store, txSteps) {
  return create(store, (draft) => {
    txSteps.forEach((txStep) => {
      applyTxStep(draft, txStep);
    });
  });
}

// ../node_modules/@instantdb/core/dist/module/datalog.js
function isVariable(x) {
  return typeof x === "string" && x.startsWith("?");
}
function matchVariable(variable, triplePart, context) {
  if (context.hasOwnProperty(variable)) {
    const bound = context[variable];
    return matchPart(bound, triplePart, context);
  }
  return Object.assign(Object.assign({}, context), { [variable]: triplePart });
}
function matchExact(patternPart, triplePart, context) {
  return patternPart === triplePart ? context : null;
}
function matchWithArgMap(patternPart, triplePart, context) {
  const { in: inList } = patternPart;
  if (inList && inList.includes(triplePart)) {
    return context;
  }
  return null;
}
function matcherForPatternPart(patternPart) {
  switch (typeof patternPart) {
    case "string":
      return patternPart.startsWith("?") ? matchVariable : matchExact;
    case "object":
      return matchWithArgMap;
    default:
      return matchExact;
  }
}
function matchPart(patternPart, triplePart, context) {
  if (!context)
    return null;
  const matcher = matcherForPatternPart(patternPart);
  return matcher(patternPart, triplePart, context);
}
function matchPattern(pattern, triple, context) {
  return pattern.reduce((context2, patternPart, idx) => {
    const triplePart = triple[idx];
    return matchPart(patternPart, triplePart, context2);
  }, context);
}
function querySingle(store, pattern, context) {
  return relevantTriples(store, pattern, context).map((triple) => matchPattern(pattern, triple, context)).filter((x) => x);
}
function queryPattern(store, pattern, contexts) {
  if (pattern.or) {
    return pattern.or.patterns.flatMap((patterns) => {
      return queryWhere(store, patterns, contexts);
    });
  }
  if (pattern.and) {
    return pattern.and.patterns.reduce((contexts2, patterns) => {
      return queryWhere(store, patterns, contexts2);
    }, contexts);
  }
  return contexts.flatMap((context) => querySingle(store, pattern, context));
}
function queryWhere(store, patterns, contexts = [{}]) {
  return patterns.reduce((contexts2, pattern) => {
    return queryPattern(store, pattern, contexts2);
  }, contexts);
}
function actualize(context, find) {
  if (Array.isArray(find)) {
    return find.map((findPart) => actualize(context, findPart));
  }
  return isVariable(find) ? context[find] : find;
}
function query(store, { find, where }) {
  const contexts = queryWhere(store, where);
  return contexts.map((context) => actualize(context, find));
}
function relevantTriples(store, pattern, context) {
  return getTriples(store, actualize(context, pattern));
}

// ../node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// ../node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// ../node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// ../node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i2 = 0; i2 < 256; ++i2) {
  byteToHex.push((i2 + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}

// ../node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  const arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
var parse_default = parse;

// ../node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = [];
  for (let i2 = 0; i2 < str.length; ++i2) {
    bytes.push(str.charCodeAt(i2));
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i2 = 0; i2 < 16; ++i2) {
        buf[offset + i2] = bytes[i2];
      }
      return buf;
    }
    return unsafeStringify(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL2;
  return generateUUID;
}

// ../node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  if (typeof bytes === "string") {
    const msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (let i2 = 0; i2 < msg.length; ++i2) {
      bytes[i2] = msg.charCodeAt(i2);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  const output = [];
  const length32 = input.length * 32;
  const hexTab = "0123456789abcdef";
  for (let i2 = 0; i2 < length32; i2 += 8) {
    const x = input[i2 >> 5] >>> i2 % 32 & 255;
    const hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  x[len >> 5] |= 128 << len % 32;
  x[getOutputLength(len) - 1] = len;
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;
  for (let i2 = 0; i2 < x.length; i2 += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c;
    const oldd = d;
    a = md5ff(a, b, c, d, x[i2], 7, -680876936);
    d = md5ff(d, a, b, c, x[i2 + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i2 + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i2 + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i2 + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i2 + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i2 + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i2 + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i2 + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i2 + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i2 + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i2 + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i2 + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i2 + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i2 + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i2 + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i2 + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i2 + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i2 + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i2], 20, -373897302);
    a = md5gg(a, b, c, d, x[i2 + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i2 + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i2 + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i2 + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i2 + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i2 + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i2 + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i2 + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i2 + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i2 + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i2 + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i2 + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i2 + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i2 + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i2 + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i2 + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i2 + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i2 + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i2 + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i2 + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i2 + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i2], 11, -358537222);
    c = md5hh(c, d, a, b, x[i2 + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i2 + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i2 + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i2 + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i2 + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i2 + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i2], 6, -198630844);
    d = md5ii(d, a, b, c, x[i2 + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i2 + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i2 + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i2 + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i2 + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i2 + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i2 + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i2 + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i2 + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i2 + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i2 + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i2 + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i2 + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i2 + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i2 + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return [a, b, c, d];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  const length8 = input.length * 8;
  const output = new Uint32Array(getOutputLength(length8));
  for (let i2 = 0; i2 < length8; i2 += 8) {
    output[i2 >> 5] |= (input[i2 / 8] & 255) << i2 % 32;
  }
  return output;
}
function safeAdd(x, y) {
  const lsw = (x & 65535) + (y & 65535);
  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
var md5_default = md5;

// ../node_modules/uuid/dist/esm-browser/v3.js
var v3 = v35("v3", 48, md5_default);

// ../node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// ../node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i2 = 0; i2 < 16; ++i2) {
      buf[offset + i2] = rnds[i2];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// ../node_modules/uuid/dist/esm-browser/sha1.js
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1(bytes) {
  const K = [1518500249, 1859775393, 2400959708, 3395469782];
  const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    const msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (let i2 = 0; i2 < msg.length; ++i2) {
      bytes.push(msg.charCodeAt(i2));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  const l = bytes.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);
  for (let i2 = 0; i2 < N; ++i2) {
    const arr = new Uint32Array(16);
    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i2 * 64 + j * 4] << 24 | bytes[i2 * 64 + j * 4 + 1] << 16 | bytes[i2 * 64 + j * 4 + 2] << 8 | bytes[i2 * 64 + j * 4 + 3];
    }
    M[i2] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (let i2 = 0; i2 < N; ++i2) {
    const W = new Uint32Array(80);
    for (let t = 0; t < 16; ++t) {
      W[t] = M[i2][t];
    }
    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }
    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];
    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var sha1_default = sha1;

// ../node_modules/uuid/dist/esm-browser/v5.js
var v5 = v35("v5", 80, sha1_default);

// ../node_modules/@instantdb/core/dist/module/utils/uuid.js
function uuidToByteArray(uuid) {
  const hex = uuid.replace(/-/g, "");
  const bytes = [];
  for (let i2 = 0; i2 < hex.length; i2 += 2) {
    bytes.push(parseInt(hex.substring(i2, i2 + 2), 16));
  }
  return bytes;
}
function compareByteArrays(a, b) {
  for (let i2 = 0; i2 < a.length; i2++) {
    if (a[i2] < b[i2])
      return -1;
    if (a[i2] > b[i2])
      return 1;
  }
  return 0;
}
function uuidCompare(uuid_a, uuid_b) {
  return compareByteArrays(uuidToByteArray(uuid_a), uuidToByteArray(uuid_b));
}
function id() {
  return v4_default();
}
var uuid_default = id;

// ../node_modules/@instantdb/core/dist/module/instatx.js
function transactionChunk(etype, id2, prevOps) {
  return new Proxy({}, {
    get: (_target, cmd) => {
      if (cmd === "__ops")
        return prevOps;
      return (args) => {
        return transactionChunk(etype, id2, [
          ...prevOps,
          [cmd, etype, id2, args]
        ]);
      };
    }
  });
}
function lookup(attribute, value) {
  return `lookup__${attribute}__${JSON.stringify(value)}`;
}
function isLookup(k) {
  return k.startsWith("lookup__");
}
function parseLookup(k) {
  const [_, attribute, ...vJSON] = k.split("__");
  return [attribute, JSON.parse(vJSON.join("__"))];
}
function etypeChunk(etype) {
  return new Proxy({}, {
    get(_target, id2) {
      if (isLookup(id2)) {
        return transactionChunk(etype, parseLookup(id2), []);
      }
      return transactionChunk(etype, id2, []);
    }
  });
}
function txInit() {
  return new Proxy({}, {
    get(_target, ns) {
      return etypeChunk(ns);
    }
  });
}
var tx = txInit();
function getOps(x) {
  return x.__ops;
}

// ../node_modules/@instantdb/core/dist/module/instaml.js
function rewriteStep(attrMapping, txStep) {
  const { attrIdMap, refSwapAttrIds } = attrMapping;
  const rewritten = [];
  for (const part of txStep) {
    const newValue = attrIdMap[part];
    if (newValue) {
      rewritten.push(newValue);
    } else if (Array.isArray(part) && part.length == 2 && attrIdMap[part[0]]) {
      const [aid, value] = part;
      rewritten.push([attrIdMap[aid], value]);
    } else {
      rewritten.push(part);
    }
  }
  const [action] = txStep;
  if ((action === "add-triple" || action === "retract-triple") && refSwapAttrIds.has(txStep[2])) {
    const tmp = rewritten[1];
    rewritten[1] = rewritten[3];
    rewritten[3] = tmp;
  }
  return rewritten;
}
function getAttrByFwdIdentName(attrs, inputEtype, inputIdentName) {
  return Object.values(attrs).find((attr) => {
    const [_id, etype, label] = attr["forward-identity"];
    return etype === inputEtype && label === inputIdentName;
  });
}
function getAttrByReverseIdentName(attrs, inputEtype, inputIdentName) {
  return Object.values(attrs).find((attr) => {
    const revIdent = attr["reverse-identity"];
    if (!revIdent)
      return false;
    const [_id, etype, label] = revIdent;
    return etype === inputEtype && label === inputIdentName;
  });
}
function explodeLookupRef(eid) {
  if (Array.isArray(eid)) {
    return eid;
  }
  const entries = Object.entries(eid);
  if (entries.length !== 1) {
    throw new Error("lookup must be an object with a single unique attr and value.");
  }
  return entries[0];
}
function isRefLookupIdent(attrs, etype, identName) {
  return identName.indexOf(".") !== -1 && // attr names can have `.` in them, so use the attr we find with a `.`
  // before assuming it's a ref lookup.
  !getAttrByFwdIdentName(attrs, etype, identName);
}
function extractRefLookupFwdName(identName) {
  const [fwdName, idIdent, ...rest] = identName.split(".");
  if (rest.length > 0 || idIdent !== "id") {
    throw new Error(`${identName} is not a valid lookup attribute.`);
  }
  return fwdName;
}
function lookupIdentToAttr(attrs, etype, identName) {
  if (!isRefLookupIdent(attrs, etype, identName)) {
    return getAttrByFwdIdentName(attrs, etype, identName);
  }
  const fwdName = extractRefLookupFwdName(identName);
  const refAttr = getAttrByFwdIdentName(attrs, etype, fwdName);
  if (refAttr && refAttr["value-type"] !== "ref") {
    throw new Error(`${identName} does not reference a valid link attribute.`);
  }
  return refAttr;
}
function lookupPairOfEid(eid) {
  if (typeof eid === "string" && !isLookup(eid)) {
    return null;
  }
  return typeof eid === "string" && isLookup(eid) ? parseLookup(eid) : explodeLookupRef(eid);
}
function extractLookup(attrs, etype, eid) {
  const lookupPair = lookupPairOfEid(eid);
  if (lookupPair === null) {
    return eid;
  }
  const [identName, value] = lookupPair;
  const attr = lookupIdentToAttr(attrs, etype, identName);
  if (!attr || !attr["unique?"]) {
    throw new Error(`${identName} is not a unique attribute.`);
  }
  return [attr.id, value];
}
function expandLink(attrs, [etype, eidA, obj]) {
  const addTriples = Object.entries(obj).flatMap(([label, eidOrEids]) => {
    const eids = Array.isArray(eidOrEids) ? eidOrEids : [eidOrEids];
    const fwdAttr = getAttrByFwdIdentName(attrs, etype, label);
    const revAttr = getAttrByReverseIdentName(attrs, etype, label);
    return eids.map((eidB) => {
      const txStep = fwdAttr ? [
        "add-triple",
        extractLookup(attrs, etype, eidA),
        fwdAttr.id,
        extractLookup(attrs, fwdAttr["reverse-identity"][1], eidB)
      ] : [
        "add-triple",
        extractLookup(attrs, revAttr["forward-identity"][1], eidB),
        revAttr.id,
        extractLookup(attrs, etype, eidA)
      ];
      return txStep;
    });
  });
  return addTriples;
}
function expandUnlink(attrs, [etype, eidA, obj]) {
  const retractTriples = Object.entries(obj).flatMap(([label, eidOrEids]) => {
    const eids = Array.isArray(eidOrEids) ? eidOrEids : [eidOrEids];
    const fwdAttr = getAttrByFwdIdentName(attrs, etype, label);
    const revAttr = getAttrByReverseIdentName(attrs, etype, label);
    return eids.map((eidB) => {
      const txStep = fwdAttr ? [
        "retract-triple",
        extractLookup(attrs, etype, eidA),
        fwdAttr.id,
        extractLookup(attrs, fwdAttr["reverse-identity"][1], eidB)
      ] : [
        "retract-triple",
        extractLookup(attrs, revAttr["forward-identity"][1], eidB),
        revAttr.id,
        extractLookup(attrs, etype, eidA)
      ];
      return txStep;
    });
  });
  return retractTriples;
}
function expandUpdate(attrs, [etype, eid, obj]) {
  const lookup2 = extractLookup(attrs, etype, eid);
  const attrTuples = [["id", extractLookup(attrs, etype, eid)]].concat(Object.entries(obj)).map(([identName, value]) => {
    const attr = getAttrByFwdIdentName(attrs, etype, identName);
    return ["add-triple", lookup2, attr.id, value];
  });
  return attrTuples;
}
function expandDelete(attrs, [etype, eid]) {
  const lookup2 = extractLookup(attrs, etype, eid);
  return [["delete-entity", lookup2, etype]];
}
function expandDeepMerge(attrs, [etype, eid, obj]) {
  const lookup2 = extractLookup(attrs, etype, eid);
  const attrTuples = Object.entries(obj).map(([identName, value]) => {
    const attr = getAttrByFwdIdentName(attrs, etype, identName);
    const coercedValue = immutableDeepReplace(value, void 0, null);
    return ["deep-merge-triple", lookup2, attr.id, coercedValue];
  });
  const idTuple = [
    "add-triple",
    lookup2,
    getAttrByFwdIdentName(attrs, etype, "id").id,
    lookup2
  ];
  return [idTuple].concat(attrTuples);
}
function toTxSteps(attrs, [action, ...args]) {
  switch (action) {
    case "merge":
      return expandDeepMerge(attrs, args);
    case "update":
      return expandUpdate(attrs, args);
    case "link":
      return expandLink(attrs, args);
    case "unlink":
      return expandUnlink(attrs, args);
    case "delete":
      return expandDelete(attrs, args);
    default:
      throw new Error(`unsupported action ${action}`);
  }
}
function createObjectAttr(etype, label, props) {
  const attrId = uuid_default();
  const fwdIdentId = uuid_default();
  const fwdIdent = [fwdIdentId, etype, label];
  return Object.assign({ id: attrId, "forward-identity": fwdIdent, "value-type": "blob", cardinality: "one", "unique?": false, "index?": false, isUnsynced: true }, props || {});
}
function createRefAttr(etype, label, props) {
  const attrId = uuid_default();
  const fwdIdentId = uuid_default();
  const revIdentId = uuid_default();
  const fwdIdent = [fwdIdentId, etype, label];
  const revIdent = [revIdentId, label, etype];
  return Object.assign({ id: attrId, "forward-identity": fwdIdent, "reverse-identity": revIdent, "value-type": "ref", cardinality: "many", "unique?": false, "index?": false, isUnsynced: true }, props || {});
}
var OBJ_ACTIONS = /* @__PURE__ */ new Set(["update", "merge", "link", "unlink"]);
var REF_ACTIONS = /* @__PURE__ */ new Set(["link", "unlink"]);
var UPDATE_ACTIONS = /* @__PURE__ */ new Set(["update", "merge"]);
var SUPPORTS_LOOKUP_ACTIONS = /* @__PURE__ */ new Set([
  "link",
  "unlink",
  "update",
  "merge",
  "delete"
]);
var lookupProps = { "unique?": true, "index?": true };
var refLookupProps = Object.assign(Object.assign({}, lookupProps), { cardinality: "one" });
function createMissingAttrs(existingAttrs, ops) {
  const [addedIds, attrs, addOps] = [/* @__PURE__ */ new Set(), Object.assign({}, existingAttrs), []];
  function addAttr2(attr) {
    attrs[attr.id] = attr;
    addOps.push(["add-attr", attr]);
    addedIds.add(attr.id);
  }
  function addUnsynced(attr) {
    if ((attr === null || attr === void 0 ? void 0 : attr.isUnsynced) && !addedIds.has(attr.id)) {
      addOps.push(["add-attr", attr]);
      addedIds.add(attr.id);
    }
  }
  for (const op of ops) {
    const [action, etype, eid, obj] = op;
    if (SUPPORTS_LOOKUP_ACTIONS.has(action)) {
      const lookupPair = lookupPairOfEid(eid);
      if (lookupPair) {
        const identName = lookupPair[0];
        if (isRefLookupIdent(attrs, etype, identName)) {
          const label = extractRefLookupFwdName(identName);
          const fwdAttr = getAttrByFwdIdentName(attrs, etype, label);
          const revAttr = getAttrByReverseIdentName(attrs, etype, label);
          if (!fwdAttr && !revAttr) {
            addAttr2(createRefAttr(etype, label, refLookupProps));
          }
          addUnsynced(fwdAttr);
          addUnsynced(revAttr);
        } else {
          const attr = getAttrByFwdIdentName(attrs, etype, identName);
          if (!attr) {
            addAttr2(createObjectAttr(etype, identName, lookupProps));
          }
          addUnsynced(attr);
        }
      }
    }
  }
  for (const op of ops) {
    const [action, etype, eid, obj] = op;
    if (OBJ_ACTIONS.has(action)) {
      const labels = Object.keys(obj);
      labels.push("id");
      for (const label of labels) {
        const fwdAttr = getAttrByFwdIdentName(attrs, etype, label);
        addUnsynced(fwdAttr);
        if (UPDATE_ACTIONS.has(action)) {
          if (!fwdAttr) {
            addAttr2(createObjectAttr(etype, label));
          }
        }
        if (REF_ACTIONS.has(action)) {
          const revAttr = getAttrByReverseIdentName(attrs, etype, label);
          if (!fwdAttr && !revAttr) {
            addAttr2(createRefAttr(etype, label));
          }
          addUnsynced(revAttr);
        }
      }
    }
  }
  return [attrs, addOps];
}
function transform(attrs, inputChunks) {
  const chunks = Array.isArray(inputChunks) ? inputChunks : [inputChunks];
  const ops = chunks.flatMap((tx2) => getOps(tx2));
  const [newAttrs, addAttrTxSteps] = createMissingAttrs(attrs, ops);
  const txSteps = ops.flatMap((op) => toTxSteps(newAttrs, op));
  return [...addAttrTxSteps, ...txSteps];
}

// ../node_modules/@instantdb/core/dist/module/instaql.js
var _seed2 = 0;
function wildcard(friendlyName) {
  return makeVarImpl(`_${friendlyName}`, _seed2++);
}
function makeVarImpl(x, level) {
  return `?${x}-${level}`;
}
var AttrNotFoundError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "AttrNotFoundError";
  }
};
function getPrimaryKeyAttr(store, ns) {
  const primary = Object.values(store.attrs).find((a) => {
    var _b;
    return a["primary?"] && ((_b = a["forward-identity"]) === null || _b === void 0 ? void 0 : _b[1]) === ns;
  });
  if (primary) {
    return primary;
  }
  return getAttrByFwdIdentName(store.attrs, ns, "id");
}
function idAttr(store, ns) {
  const attr = getPrimaryKeyAttr(store, ns);
  if (!attr) {
    throw new AttrNotFoundError(`Could not find id attr for ${ns}`);
  }
  return attr;
}
function defaultWhere(makeVar, store, etype, level) {
  return [eidWhere(makeVar, store, etype, level)];
}
function eidWhere(makeVar, store, etype, level) {
  return [
    makeVar(etype, level),
    idAttr(store, etype).id,
    makeVar(etype, level),
    makeVar("time", level)
  ];
}
function replaceInAttrPat(attrPat, needle, v) {
  return attrPat.map((x) => x === needle ? v : x);
}
function refAttrPat(makeVar, store, etype, level, label) {
  const fwdAttr = getAttrByFwdIdentName(store.attrs, etype, label);
  const revAttr = getAttrByReverseIdentName(store.attrs, etype, label);
  const attr = fwdAttr || revAttr;
  if (!attr) {
    throw new AttrNotFoundError(`Could not find attr for ${[etype, label]}`);
  }
  if (attr["value-type"] !== "ref") {
    throw new Error(`Attr ${attr.id} is not a ref`);
  }
  const [_f, fwdEtype] = attr["forward-identity"];
  const [_r, revEtype] = attr["reverse-identity"];
  const nextLevel = level + 1;
  const attrPat = fwdAttr ? [
    makeVar(fwdEtype, level),
    attr.id,
    makeVar(revEtype, nextLevel),
    wildcard("time")
  ] : [
    makeVar(fwdEtype, nextLevel),
    attr.id,
    makeVar(revEtype, level),
    wildcard("time")
  ];
  const nextEtype = fwdAttr ? revEtype : fwdEtype;
  const isForward = Boolean(fwdAttr);
  return [nextEtype, nextLevel, attrPat, attr, isForward];
}
function valueAttrPat(makeVar, store, valueEtype, valueLevel, valueLabel, v) {
  const attr = getAttrByFwdIdentName(store.attrs, valueEtype, valueLabel);
  if (!attr) {
    throw new AttrNotFoundError(`No attr for etype = ${valueEtype} label = ${valueLabel} value-label`);
  }
  return [makeVar(valueEtype, valueLevel), attr.id, v, wildcard("time")];
}
function refAttrPats(makeVar, store, etype, level, refsPath) {
  const [lastEtype, lastLevel, attrPats] = refsPath.reduce((acc, label) => {
    const [etype2, level2, attrPats2] = acc;
    const [nextEtype, nextLevel, attrPat] = refAttrPat(makeVar, store, etype2, level2, label);
    return [nextEtype, nextLevel, [...attrPats2, attrPat]];
  }, [etype, level, []]);
  return [lastEtype, lastLevel, attrPats];
}
function whereCondAttrPats(makeVar, store, etype, level, path, v) {
  const refsPath = path.slice(0, path.length - 1);
  const valueLabel = path[path.length - 1];
  const [lastEtype, lastLevel, refPats] = refAttrPats(makeVar, store, etype, level, refsPath);
  const valuePat = valueAttrPat(makeVar, store, lastEtype, lastLevel, valueLabel, v);
  return refPats.concat([valuePat]);
}
function withJoin(where, join) {
  return join ? [join].concat(where) : where;
}
function isOrClauses([k, v]) {
  return k === "or" && Array.isArray(v);
}
function isAndClauses([k, v]) {
  return k === "and" && Array.isArray(v);
}
function genMakeVar(baseMakeVar, etype, orIdx) {
  return (x, lvl) => {
    if (x == etype) {
      return baseMakeVar(x, lvl);
    }
    return `${baseMakeVar(x, lvl)}-${orIdx}`;
  };
}
function parseWhereClauses(makeVar, clauseType, store, etype, level, whereValue) {
  const patterns = whereValue.map((w, i2) => {
    const makeNamespacedVar = genMakeVar(makeVar, etype, i2);
    return parseWhere(makeNamespacedVar, store, etype, level, w);
  });
  const joinSym = makeVar(etype, level);
  return { [clauseType]: { patterns, joinSym } };
}
function parseWhere(makeVar, store, etype, level, where) {
  return Object.entries(where).flatMap(([k, v]) => {
    if (isOrClauses([k, v])) {
      return parseWhereClauses(makeVar, "or", store, etype, level, v);
    }
    if (isAndClauses([k, v])) {
      return parseWhereClauses(makeVar, "and", store, etype, level, v);
    }
    const path = k.split(".");
    return whereCondAttrPats(makeVar, store, etype, level, path, v);
  });
}
function makeWhere(store, etype, level, where) {
  const makeVar = makeVarImpl;
  if (!where) {
    return defaultWhere(makeVar, store, etype, level);
  }
  const parsedWhere = parseWhere(makeVar, store, etype, level, where);
  return parsedWhere.concat(defaultWhere(makeVar, store, etype, level));
}
function makeFind(makeVar, etype, level) {
  return [makeVar(etype, level), makeVar("time", level)];
}
function makeJoin(makeVar, store, etype, level, label, eid) {
  const [nextEtype, nextLevel, pat, attr, isForward] = refAttrPat(makeVar, store, etype, level, label);
  const actualized = replaceInAttrPat(pat, makeVar(etype, level), eid);
  return [nextEtype, nextLevel, actualized, attr, isForward];
}
function extendObjects(makeVar, store, { etype, level, form }, objects) {
  const children = Object.keys(form).filter((c) => c !== "$");
  if (!children.length) {
    return Object.values(objects);
  }
  return Object.entries(objects).map(([eid, parent]) => {
    const childResults = children.map((label) => {
      var _b, _c, _d;
      const isSingular = Boolean(store.cardinalityInference && ((_d = (_c = (_b = store.linkIndex) === null || _b === void 0 ? void 0 : _b[etype]) === null || _c === void 0 ? void 0 : _c[label]) === null || _d === void 0 ? void 0 : _d.isSingular));
      try {
        const [nextEtype, nextLevel, join] = makeJoin(makeVar, store, etype, level, label, eid);
        const childrenArray = queryOne(store, {
          etype: nextEtype,
          level: nextLevel,
          form: form[label],
          join
        });
        const childOrChildren = isSingular ? childrenArray[0] : childrenArray;
        return { [label]: childOrChildren };
      } catch (e) {
        if (e instanceof AttrNotFoundError) {
          return { [label]: isSingular ? void 0 : [] };
        }
        throw e;
      }
    });
    return childResults.reduce((parent2, child) => {
      return Object.assign(Object.assign({}, parent2), child);
    }, parent);
  });
}
function cursorCompare(direction, typ) {
  switch (direction) {
    case "asc":
      switch (typ) {
        case "number":
          return (x, y) => x < y;
        case "uuid":
          return (x, y) => uuidCompare(x, y) === -1;
      }
    case "desc":
      switch (typ) {
        case "number":
          return (x, y) => x > y;
        case "uuid":
          return (x, y) => uuidCompare(x, y) === 1;
      }
  }
}
function isBefore(startCursor, direction, [e, _a, _v, t]) {
  return cursorCompare(direction, "number")(t, startCursor[3]) || t === startCursor[3] && cursorCompare(direction, "uuid")(e, startCursor[0]);
}
function runDataloadAndReturnObjects(store, etype, direction, pageInfo, dq) {
  const aid = idAttr(store, etype).id;
  const idVecs = query(store, dq).sort(([_, tsA], [__, tsB]) => {
    return direction === "desc" ? tsB - tsA : tsA - tsB;
  });
  let objects = {};
  const startCursor = pageInfo === null || pageInfo === void 0 ? void 0 : pageInfo["start-cursor"];
  const blobAttrs2 = blobAttrs(store, etype);
  for (const [id2, time] of idVecs) {
    if (startCursor && aid === startCursor[1] && isBefore(startCursor, direction, [id2, aid, id2, time])) {
      continue;
    }
    const obj = getAsObject(store, blobAttrs2, id2);
    if (obj) {
      objects[id2] = obj;
    }
  }
  return objects;
}
function determineOrder(form) {
  var _b;
  const orderOpts = (_b = form.$) === null || _b === void 0 ? void 0 : _b.order;
  if (!orderOpts) {
    return "asc";
  }
  return orderOpts[Object.keys(orderOpts)[0]] || "asc";
}
function resolveObjects(store, { etype, level, form, join, pageInfo }) {
  var _b, _c, _d, _e, _g, _h, _j;
  const limit = ((_b = form.$) === null || _b === void 0 ? void 0 : _b.limit) || ((_c = form.$) === null || _c === void 0 ? void 0 : _c.first) || ((_d = form.$) === null || _d === void 0 ? void 0 : _d.last);
  const offset = (_e = form.$) === null || _e === void 0 ? void 0 : _e.offset;
  const before = (_g = form.$) === null || _g === void 0 ? void 0 : _g.before;
  const after = (_h = form.$) === null || _h === void 0 ? void 0 : _h.after;
  if ((offset || before || after) && (!pageInfo || !pageInfo["start-cursor"])) {
    return [];
  }
  const where = withJoin(makeWhere(store, etype, level, (_j = form.$) === null || _j === void 0 ? void 0 : _j.where), join);
  const find = makeFind(makeVarImpl, etype, level);
  const objs = runDataloadAndReturnObjects(store, etype, determineOrder(form), pageInfo, { where, find });
  if (limit != null) {
    const entries = Object.entries(objs);
    if (entries.length <= limit) {
      return objs;
    }
    return Object.fromEntries(entries.slice(0, limit));
  }
  return objs;
}
function guardedResolveObjects(store, opts) {
  try {
    return resolveObjects(store, opts);
  } catch (e) {
    if (e instanceof AttrNotFoundError) {
      return {};
    }
    throw e;
  }
}
function queryOne(store, opts) {
  const objects = guardedResolveObjects(store, opts);
  return extendObjects(makeVarImpl, store, opts, objects);
}
function formatPageInfo(pageInfo) {
  const res = {};
  for (const [k, v] of Object.entries(pageInfo)) {
    res[k] = {
      startCursor: v["start-cursor"],
      endCursor: v["end-cursor"],
      hasNextPage: v["has-next-page?"],
      hasPreviousPage: v["has-previous-page?"]
    };
  }
  return res;
}
function query2({ store, pageInfo, aggregate }, q) {
  const data = Object.keys(q).reduce((res, k) => {
    if (aggregate === null || aggregate === void 0 ? void 0 : aggregate[k]) {
      return res;
    }
    res[k] = queryOne(store, {
      etype: k,
      form: q[k],
      level: 0,
      pageInfo: pageInfo === null || pageInfo === void 0 ? void 0 : pageInfo[k]
    });
    return res;
  }, {});
  const result = { data };
  if (pageInfo) {
    result.pageInfo = formatPageInfo(pageInfo);
  }
  if (aggregate) {
    result.aggregate = aggregate;
  }
  return result;
}

// ../node_modules/@instantdb/core/dist/module/IndexedDBStorage.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var IndexedDBStorage = class {
  constructor(dbName) {
    this.dbName = dbName;
    this._storeName = "kv";
    this._dbPromise = this._init();
  }
  _init() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, 1);
      request.onerror = (event) => {
        reject(event);
      };
      request.onsuccess = (event) => {
        resolve(event.target.result);
      };
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        db.createObjectStore(this._storeName);
      };
    });
  }
  getItem(k) {
    return __awaiter(this, void 0, void 0, function* () {
      const db = yield this._dbPromise;
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([this._storeName], "readonly");
        const objectStore = transaction.objectStore(this._storeName);
        const request = objectStore.get(k);
        request.onerror = (event) => {
          reject(event);
        };
        request.onsuccess = (_event) => {
          if (request.result) {
            resolve(request.result);
          } else {
            resolve(null);
          }
        };
      });
    });
  }
  setItem(k, v) {
    return __awaiter(this, void 0, void 0, function* () {
      const db = yield this._dbPromise;
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([this._storeName], "readwrite");
        const objectStore = transaction.objectStore(this._storeName);
        const request = objectStore.put(v, k);
        request.onerror = (event) => {
          reject(event);
        };
        request.onsuccess = (_event) => {
          resolve();
        };
      });
    });
  }
};

// ../node_modules/@instantdb/core/dist/module/WindowNetworkListener.js
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var WindowNetworkListener = class {
  static getIsOnline() {
    return __awaiter2(this, void 0, void 0, function* () {
      return navigator.onLine;
    });
  }
  static listen(f2) {
    const onOnline = () => {
      f2(true);
    };
    const onOffline = () => {
      f2(false);
    };
    addEventListener("online", onOnline);
    addEventListener("offline", onOffline);
    return () => {
      removeEventListener("online", onOnline);
      removeEventListener("offline", onOffline);
    };
  }
};

// ../node_modules/@instantdb/core/dist/module/utils/fetch.js
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function jsonFetch(input, init2) {
  return __awaiter3(this, void 0, void 0, function* () {
    const res = yield fetch(input, init2);
    const json2 = yield res.json();
    return res.status === 200 ? Promise.resolve(json2) : Promise.reject({ status: res.status, body: json2 });
  });
}

// ../node_modules/@instantdb/core/dist/module/authAPI.js
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function sendMagicCode({ apiURI, appId, email }) {
  return jsonFetch(`${apiURI}/runtime/auth/send_magic_code`, {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({ "app-id": appId, email })
  });
}
function verifyMagicCode(_a) {
  return __awaiter4(this, arguments, void 0, function* ({ apiURI, appId, email, code }) {
    const res = yield jsonFetch(`${apiURI}/runtime/auth/verify_magic_code`, {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify({ "app-id": appId, email, code })
    });
    return res;
  });
}
function verifyRefreshToken(_a) {
  return __awaiter4(this, arguments, void 0, function* ({ apiURI, appId, refreshToken }) {
    const res = yield jsonFetch(`${apiURI}/runtime/auth/verify_refresh_token`, {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify({
        "app-id": appId,
        "refresh-token": refreshToken
      })
    });
    return res;
  });
}
function exchangeCodeForToken(_a) {
  return __awaiter4(this, arguments, void 0, function* ({ apiURI, appId, code, codeVerifier }) {
    const res = yield jsonFetch(`${apiURI}/runtime/oauth/token`, {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify({
        app_id: appId,
        code,
        code_verifier: codeVerifier
      })
    });
    return res;
  });
}
function signInWithIdToken(_a) {
  return __awaiter4(this, arguments, void 0, function* ({ apiURI, appId, nonce, idToken, clientName, refreshToken }) {
    const res = yield jsonFetch(`${apiURI}/runtime/oauth/id_token`, {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify({
        app_id: appId,
        nonce,
        id_token: idToken,
        client_name: clientName,
        refresh_token: refreshToken
      })
    });
    return res;
  });
}
function signOut(_a) {
  return __awaiter4(this, arguments, void 0, function* ({ apiURI, appId, refreshToken }) {
    const res = yield jsonFetch(`${apiURI}/runtime/signout`, {
      method: "POST",
      headers: {
        "content-type": "application/json"
      },
      body: JSON.stringify({
        app_id: appId,
        refresh_token: refreshToken
      })
    });
    return res;
  });
}

// ../node_modules/@instantdb/core/dist/module/StorageAPI.js
var __awaiter5 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getSignedUploadUrl(_a) {
  return __awaiter5(this, arguments, void 0, function* ({ apiURI, appId, fileName, refreshToken, metadata = {} }) {
    const { data } = yield jsonFetch(`${apiURI}/storage/signed-upload-url`, {
      method: "POST",
      headers: {
        "content-type": "application/json",
        authorization: `Bearer ${refreshToken}`
      },
      body: JSON.stringify({
        app_id: appId,
        filename: fileName
      })
    });
    return data;
  });
}
function upload(presignedUrl, file) {
  return __awaiter5(this, void 0, void 0, function* () {
    const response = yield fetch(presignedUrl, {
      method: "PUT",
      body: file,
      headers: {
        "Content-Type": file.type
      }
    });
    return response.ok;
  });
}
function getDownloadUrl(_a) {
  return __awaiter5(this, arguments, void 0, function* ({ apiURI, appId, path, refreshToken }) {
    const { data } = yield jsonFetch(`${apiURI}/storage/signed-download-url?app_id=${appId}&filename=${encodeURIComponent(path)}`, {
      method: "GET",
      headers: {
        "content-type": "application/json",
        authorization: `Bearer ${refreshToken}`
      }
    });
    return data;
  });
}
function deleteFile(_a) {
  return __awaiter5(this, arguments, void 0, function* ({ apiURI, appId, path, refreshToken }) {
    const { data } = yield jsonFetch(`${apiURI}/storage/files?app_id=${appId}&filename=${encodeURIComponent(path)}`, {
      method: "DELETE",
      headers: {
        "content-type": "application/json",
        authorization: `Bearer ${refreshToken}`
      }
    });
    return data;
  });
}

// ../node_modules/@instantdb/core/dist/module/utils/pick.js
function pick(obj, keys) {
  if (!keys)
    return obj;
  const ret = {};
  keys.forEach((key) => {
    ret[key] = obj[key];
  });
  return ret;
}

// ../node_modules/@instantdb/core/dist/module/presence.js
function buildPresenceSlice(data, opts, userPeerId) {
  var _a, _b;
  const slice = {
    peers: {}
  };
  const includeUser = opts && "user" in opts ? opts.user : true;
  if (includeUser) {
    const user = pick((_a = data.user) !== null && _a !== void 0 ? _a : {}, opts === null || opts === void 0 ? void 0 : opts.keys);
    slice.user = Object.assign(Object.assign({}, user), { peerId: userPeerId });
  }
  for (const id2 of Object.keys((_b = data.peers) !== null && _b !== void 0 ? _b : {})) {
    const shouldIncludeAllPeers = (opts === null || opts === void 0 ? void 0 : opts.peers) === void 0;
    const isPeerIncluded = Array.isArray(opts === null || opts === void 0 ? void 0 : opts.peers) && (opts === null || opts === void 0 ? void 0 : opts.peers.includes(id2));
    if (shouldIncludeAllPeers || isPeerIncluded) {
      const peer = pick(data.peers[id2], opts === null || opts === void 0 ? void 0 : opts.keys);
      slice.peers[id2] = Object.assign(Object.assign({}, peer), { peerId: id2 });
    }
  }
  return slice;
}
function hasPresenceResponseChanged(a, b) {
  if (a.isLoading !== b.isLoading)
    return true;
  if (a.error !== b.error)
    return true;
  if (a.user || b.user) {
    if (!a.user || !b.user)
      return true;
    const same = areObjectsShallowEqual(a.user, b.user);
    if (!same)
      return true;
  }
  const sameKeys = areObjectKeysEqual(a.peers, b.peers);
  if (!sameKeys)
    return true;
  for (const id2 of Object.keys(a.peers)) {
    const same = areObjectsShallowEqual(a.peers[id2], b.peers[id2]);
    if (!same)
      return true;
  }
  return false;
}

// ../node_modules/@instantdb/core/dist/module/utils/Deferred.js
var Deferred = class {
  constructor() {
    this.promise = new Promise((resolve, reject) => {
      this._resolve = resolve;
      this._reject = reject;
    });
  }
  resolve(value) {
    this._resolve(value);
  }
  reject(reason) {
    this._reject(reason);
  }
};

// ../node_modules/@instantdb/core/dist/module/utils/PersistedObject.js
var __awaiter6 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var PersistedObject = class {
  constructor(persister, key, defaultValue, onMerge, toJSON2 = (x) => {
    return JSON.stringify(x);
  }, fromJSON2 = (x) => {
    return JSON.parse(x);
  }, saveThrottleMs = 100) {
    this._persister = persister;
    this._key = key;
    this._onMerge = onMerge;
    this._loadedCbs = [];
    this._isLoading = true;
    this.currentValue = defaultValue;
    this.toJSON = toJSON2;
    this.fromJSON = fromJSON2;
    this._saveThrottleMs = saveThrottleMs;
    this._pendingSaveCbs = [];
    this._version = 0;
    this._load();
  }
  _load() {
    return __awaiter6(this, void 0, void 0, function* () {
      const fromStorage = this.fromJSON(yield this._persister.getItem(this._key));
      this._isLoading = false;
      this._onMerge(fromStorage, this.currentValue);
      for (const cb of this._loadedCbs) {
        cb();
      }
    });
  }
  waitForLoaded() {
    return __awaiter6(this, void 0, void 0, function* () {
      if (!this._isLoading) {
        return;
      }
      const loadedPromise = new Promise((resolve) => {
        this._loadedCbs.push(resolve);
      });
      yield loadedPromise;
    });
  }
  isLoading() {
    return this._isLoading;
  }
  version() {
    return this._version;
  }
  waitForSync() {
    return __awaiter6(this, void 0, void 0, function* () {
      if (!this._nextSave) {
        return;
      }
      const syncedPromise = new Promise((resolve) => {
        this._pendingSaveCbs.push(resolve);
      });
      yield syncedPromise;
    });
  }
  _writeToStorage() {
    this._persister.setItem(this._key, this.toJSON(this.currentValue));
    for (const cb of this._pendingSaveCbs) {
      cb();
    }
    this._pendingSaveCbs.length = 0;
  }
  flush() {
    return __awaiter6(this, void 0, void 0, function* () {
      if (!this._nextSave) {
        return;
      }
      clearTimeout(this._nextSave);
      this._writeToStorage();
    });
  }
  _enqueuePersist(cb) {
    if (this._nextSave) {
      if (cb) {
        this._pendingSaveCbs.push(cb);
      }
      return;
    }
    this._nextSave = setTimeout(() => {
      this._nextSave = null;
      this._writeToStorage();
    }, this._saveThrottleMs);
  }
  set(f2, cb) {
    this._version++;
    this.currentValue = f2(this.currentValue);
    if (this._isLoading) {
      this._loadedCbs.push(() => this._enqueuePersist(cb));
    } else {
      this._enqueuePersist(cb);
    }
  }
};

// ../node_modules/@instantdb/core/dist/module/model/instaqlResult.js
function _extractTriplesHelper(idNodes, acc = []) {
  idNodes.forEach((idNode) => {
    const { data } = idNode;
    const { "datalog-result": datalogResult } = data;
    const { "join-rows": joinRows } = datalogResult;
    for (const rows of joinRows) {
      for (const triple of rows) {
        acc.push(triple);
      }
    }
    _extractTriplesHelper(idNode["child-nodes"], acc);
  });
}
function extractTriples(idNodes) {
  const triples = [];
  _extractTriplesHelper(idNodes, triples);
  return triples;
}

// ../node_modules/@instantdb/core/dist/module/utils/linkIndex.js
function createLinkIndex(schema) {
  return Object.values(schema.links).reduce((linkIndex, link) => {
    var _a, _b;
    var _c, _d;
    (_a = linkIndex[_c = link.forward.on]) !== null && _a !== void 0 ? _a : linkIndex[_c] = {};
    linkIndex[link.forward.on][link.forward.label] = {
      isForward: true,
      isSingular: link.forward.has === "one",
      link
    };
    (_b = linkIndex[_d = link.reverse.on]) !== null && _b !== void 0 ? _b : linkIndex[_d] = {};
    linkIndex[link.reverse.on][link.reverse.label] = {
      isForward: false,
      isSingular: link.reverse.has === "one",
      link
    };
    return linkIndex;
  }, {});
}

// ../node_modules/@instantdb/core/dist/module/Reactor.js
var __awaiter7 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var STATUS = {
  CONNECTING: "connecting",
  OPENED: "opened",
  AUTHENTICATED: "authenticated",
  CLOSED: "closed",
  ERRORED: "errored"
};
var QUERY_ONCE_TIMEOUT = 1e4;
var WS_OPEN_STATUS = 1;
var defaultConfig = {
  apiURI: "https://api.instantdb.com",
  websocketURI: "wss://api.instantdb.com/runtime/session"
};
var OAUTH_REDIRECT_PARAM = "_instant_oauth_redirect";
var currentUserKey = `currentUser`;
function isClient() {
  const hasWindow = typeof window !== "undefined";
  const isChrome = typeof chrome !== "undefined";
  return hasWindow || isChrome;
}
function querySubsFromJSON(str) {
  var _a;
  const parsed = JSON.parse(str);
  for (const key in parsed) {
    const v = parsed[key];
    if ((_a = v === null || v === void 0 ? void 0 : v.result) === null || _a === void 0 ? void 0 : _a.store) {
      v.result.store = fromJSON(v.result.store);
    }
  }
  return parsed;
}
function querySubsToJSON(querySubs) {
  var _a;
  const jsonSubs = {};
  for (const key in querySubs) {
    const sub = querySubs[key];
    const jsonSub = Object.assign({}, sub);
    if ((_a = sub.result) === null || _a === void 0 ? void 0 : _a.store) {
      jsonSub.result = Object.assign(Object.assign({}, sub.result), { store: toJSON(sub.result.store) });
    }
    jsonSubs[key] = jsonSub;
  }
  return JSON.stringify(jsonSubs);
}
var Reactor = class {
  constructor(config, Storage2 = IndexedDBStorage, NetworkListener = WindowNetworkListener) {
    this._isOnline = true;
    this._isShutdown = false;
    this.status = STATUS.CONNECTING;
    this.queryCbs = {};
    this.queryOnceDfds = {};
    this.authCbs = [];
    this.attrsCbs = [];
    this.mutationErrorCbs = [];
    this.mutationDeferredStore = /* @__PURE__ */ new Map();
    this._reconnectTimeoutId = null;
    this._reconnectTimeoutMs = 0;
    this._localIdPromises = {};
    this._errorMessage = null;
    this._oauthCallbackResponse = null;
    this._linkIndex = null;
    this._rooms = {};
    this._roomsPendingLeave = {};
    this._presence = {};
    this._broadcastQueue = [];
    this._broadcastSubs = {};
    this._currentUserCached = { isLoading: true, error: void 0, user: void 0 };
    this._beforeUnloadCbs = [];
    this._dataForQueryCache = {};
    this._onMergeQuerySubs = (_storageSubs, inMemorySubs) => {
      const storageSubs = _storageSubs || {};
      const ret = Object.assign({}, inMemorySubs);
      Object.entries(inMemorySubs).forEach(([hash, querySub]) => {
        var _a;
        const storageResult = (_a = storageSubs === null || storageSubs === void 0 ? void 0 : storageSubs[hash]) === null || _a === void 0 ? void 0 : _a.result;
        const memoryResult = querySub.result;
        if (storageResult && !memoryResult) {
          ret[hash].result = storageResult;
        }
      });
      const storageKsToAdd = Object.keys(storageSubs).filter((k) => !inMemorySubs[k]).slice(0, 10);
      storageKsToAdd.forEach((k) => {
        ret[k] = storageSubs[k];
      });
      this.querySubs.set((_) => ret);
      this.loadedNotifyAll();
    };
    this._onMergePendingMutations = (storageMuts, inMemoryMuts) => {
      const ret = new Map([...storageMuts.entries(), ...inMemoryMuts.entries()]);
      this.pendingMutations.set((_) => ret);
      this.loadedNotifyAll();
      const rewrittenStorageMuts = this._rewriteMutations(this.attrs, storageMuts);
      rewrittenStorageMuts.forEach((mut, k) => {
        if (!inMemoryMuts.has(k) && !mut["tx-id"]) {
          this._sendMutation(k, mut);
        }
      });
    };
    this.getPreviousResult = (q) => {
      const hash = weakHash_default(q);
      return this.dataForQuery(hash);
    };
    this.notifyOne = (hash) => {
      var _a, _b;
      const cbs = (_a = this.queryCbs[hash]) !== null && _a !== void 0 ? _a : [];
      const prevData = (_b = this._dataForQueryCache[hash]) === null || _b === void 0 ? void 0 : _b.data;
      const data = this.dataForQuery(hash);
      if (!data)
        return;
      if (areObjectsDeepEqual(data, prevData))
        return;
      cbs.forEach((r) => r.cb(data));
    };
    this.notifyOneQueryOnce = (hash) => {
      var _a;
      const dfds = (_a = this.queryOnceDfds[hash]) !== null && _a !== void 0 ? _a : [];
      const data = this.dataForQuery(hash);
      dfds.forEach((r) => {
        this._completeQueryOnce(r.q, hash, r.dfd);
        r.dfd.resolve(data);
      });
    };
    this.notifyQueryError = (hash, error) => {
      const cbs = this.queryCbs[hash] || [];
      cbs.forEach((r) => r.cb({ error }));
    };
    this.pushTx = (chunks) => {
      try {
        const txSteps = transform(this.optimisticAttrs(), chunks);
        return this.pushOps(txSteps);
      } catch (e) {
        return this.pushOps([], e);
      }
    };
    this.pushOps = (txSteps, error) => {
      const eventId = uuid_default();
      const mutation = {
        op: "transact",
        "tx-steps": txSteps,
        error
      };
      this.pendingMutations.set((prev) => {
        prev.set(eventId, mutation);
        return prev;
      });
      const dfd = new Deferred();
      this.mutationDeferredStore.set(eventId, dfd);
      this._sendMutation(eventId, mutation);
      this.notifyAll();
      return dfd.promise;
    };
    this._wsOnOpen = () => {
      log_default.info("[socket] connected");
      this._setStatus(STATUS.OPENED);
      this.getCurrentUser().then((resp) => {
        var _a;
        this._trySend(uuid_default(), {
          op: "init",
          "app-id": this.config.appId,
          "refresh-token": (_a = resp.user) === null || _a === void 0 ? void 0 : _a["refresh_token"],
          // If an admin token is provided for an app, we will
          // skip all permission checks. This is an advanced feature,
          // to let users write internal tools
          // This option is not exposed in `Config`, as it's
          // not ready for prme time
          "__admin-token": this.config.__adminToken
        });
      });
    };
    this._wsOnMessage = (e) => {
      this._handleReceive(JSON.parse(e.data.toString()));
    };
    this._wsOnError = (e) => {
      log_default.error("[socket] error: ", e);
    };
    this._wsOnClose = () => {
      this._setStatus(STATUS.CLOSED);
      for (const room of Object.values(this._rooms)) {
        room.isConnected = false;
      }
      if (this._isShutdown) {
        log_default.info("[socket-close] socket has been shut down and will not reconnect");
        return;
      }
      if (this._isManualClose) {
        this._isManualClose = false;
        log_default.info("[socket-close] manual close, will not reconnect");
        return;
      }
      log_default.info("[socket-close] scheduling reconnect", this._reconnectTimeoutMs);
      setTimeout(() => {
        this._reconnectTimeoutMs = Math.min(this._reconnectTimeoutMs + 1e3, 1e4);
        if (!this._isOnline) {
          log_default.info("[socket-close] we are offline, no need to start socket");
          return;
        }
        this._startSocket();
      }, this._reconnectTimeoutMs);
    };
    this.config = Object.assign(Object.assign({}, defaultConfig), config);
    if (this.config.schema) {
      this._linkIndex = createLinkIndex(this.config.schema);
    }
    if (!isClient()) {
      return;
    }
    if (typeof BroadcastChannel === "function") {
      this._broadcastChannel = new BroadcastChannel("@instantdb");
      this._broadcastChannel.addEventListener("message", (e) => __awaiter7(this, void 0, void 0, function* () {
        var _a;
        if (((_a = e.data) === null || _a === void 0 ? void 0 : _a.type) === "auth") {
          const res = yield this.getCurrentUser();
          this.updateUser(res.user);
        }
      }));
    }
    this._oauthCallbackResponse = this._oauthLoginInit();
    this._initStorage(Storage2);
    this.getCurrentUser();
    NetworkListener.getIsOnline().then((isOnline) => {
      this._isOnline = isOnline;
      this._startSocket();
      NetworkListener.listen((isOnline2) => {
        if (isOnline2 === this._isOnline) {
          return;
        }
        this._isOnline = isOnline2;
        if (this._isOnline) {
          this._startSocket();
        }
      });
    });
    if (typeof addEventListener !== "undefined") {
      this._beforeUnload = this._beforeUnload.bind(this);
      addEventListener("beforeunload", this._beforeUnload);
    }
  }
  _initStorage(Storage2) {
    this._persister = new Storage2(`instant_${this.config.appId}_5`);
    this.querySubs = new PersistedObject(this._persister, "querySubs", {}, this._onMergeQuerySubs, querySubsToJSON, querySubsFromJSON);
    this.pendingMutations = new PersistedObject(this._persister, "pendingMutations", /* @__PURE__ */ new Map(), this._onMergePendingMutations, (x) => {
      return JSON.stringify([...x.entries()]);
    }, (x) => {
      return new Map(JSON.parse(x));
    });
    this._beforeUnloadCbs.push(() => {
      this.pendingMutations.flush();
      this.querySubs.flush();
    });
  }
  _beforeUnload() {
    for (const cb of this._beforeUnloadCbs) {
      cb();
    }
  }
  /**
   * @param {'enqueued' | 'pending' | 'synced' | 'timeout' |  'error' } status
   * @param string clientId
   * @param {{message?: string, hint?: string, error?: Error}} [errDetails]
   */
  _finishTransaction(status, clientId, errDetails) {
    const dfd = this.mutationDeferredStore.get(clientId);
    this.mutationDeferredStore.delete(clientId);
    const ok = status !== "error" && status !== "timeout";
    if (!dfd && !ok) {
      console.error("Mutation failed", Object.assign({ status, clientId }, errDetails));
    }
    if (!dfd) {
      return;
    }
    if (ok) {
      dfd.resolve({ status, clientId });
    } else {
      dfd.reject(Object.assign({ status, clientId }, errDetails));
    }
  }
  _setStatus(status, err) {
    this.status = status;
    this._errorMessage = err;
  }
  /**
   * On refresh we clear out pending mutations that we know have been applied
   * by the server and thus those mutations are applied in the instaql result
   * returned by the server
   */
  _cleanPendingMutations(txId) {
    this.pendingMutations.set((prev) => {
      const copy = new Map(prev);
      [...prev.entries()].forEach(([eventId, mut]) => {
        if (mut["tx-id"] <= txId) {
          copy.delete(eventId);
        }
      });
      return copy;
    });
  }
  _flushEnqueuedRoomData(roomId) {
    var _a, _b;
    const enqueuedUserPresence = (_b = (_a = this._presence[roomId]) === null || _a === void 0 ? void 0 : _a.result) === null || _b === void 0 ? void 0 : _b.user;
    const enqueuedBroadcasts = this._broadcastQueue[roomId];
    this._broadcastQueue[roomId] = [];
    if (enqueuedUserPresence) {
      this._trySetPresence(roomId, enqueuedUserPresence);
    }
    if (enqueuedBroadcasts) {
      for (const item of enqueuedBroadcasts) {
        const { topic, roomType, data } = item;
        this._tryBroadcast(roomId, roomType, topic, data);
      }
    }
  }
  _handleReceive(msg) {
    var _a, _b, _c, _d;
    const enableCardinalityInference = Boolean(this.config.schema) && ("cardinalityInference" in this.config ? Boolean(this.config.cardinalityInference) : true);
    switch (msg.op) {
      case "init-ok":
        this._setStatus(STATUS.AUTHENTICATED);
        this._reconnectTimeoutMs = 0;
        this._setAttrs(msg.attrs);
        this._flushPendingMessages();
        this._sessionId = msg["session-id"];
        for (const roomId2 of Object.keys(this._rooms)) {
          this._tryJoinRoom(roomId2);
        }
        break;
      case "add-query-exists":
        this.notifyOneQueryOnce(weakHash_default(msg.q));
        break;
      case "add-query-ok":
        const { q, result, "processed-tx-id": addQueryTxId } = msg;
        this._cleanPendingMutations(addQueryTxId);
        const hash = weakHash_default(q);
        const pageInfo = (_b = (_a = result === null || result === void 0 ? void 0 : result[0]) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b["page-info"];
        const aggregate = (_d = (_c = result === null || result === void 0 ? void 0 : result[0]) === null || _c === void 0 ? void 0 : _c.data) === null || _d === void 0 ? void 0 : _d["aggregate"];
        const triples = extractTriples(result);
        const store = createStore(this.attrs, triples, enableCardinalityInference, this._linkIndex);
        this.querySubs.set((prev) => {
          prev[hash].result = { store, pageInfo, aggregate };
          return prev;
        });
        this.notifyOne(hash);
        this.notifyOneQueryOnce(hash);
        break;
      case "refresh-ok":
        const { computations, attrs, "processed-tx-id": refreshOkTxId } = msg;
        this._cleanPendingMutations(refreshOkTxId);
        this._setAttrs(attrs);
        const updates = computations.map((x) => {
          var _a2, _b2, _c2, _d2;
          const q2 = x["instaql-query"];
          const result2 = x["instaql-result"];
          const hash2 = weakHash_default(q2);
          const triples2 = extractTriples(result2);
          const store2 = createStore(this.attrs, triples2, enableCardinalityInference, this._linkIndex);
          const pageInfo2 = (_b2 = (_a2 = result2 === null || result2 === void 0 ? void 0 : result2[0]) === null || _a2 === void 0 ? void 0 : _a2.data) === null || _b2 === void 0 ? void 0 : _b2["page-info"];
          const aggregate2 = (_d2 = (_c2 = result2 === null || result2 === void 0 ? void 0 : result2[0]) === null || _c2 === void 0 ? void 0 : _c2.data) === null || _d2 === void 0 ? void 0 : _d2["aggregate"];
          return { hash: hash2, store: store2, pageInfo: pageInfo2, aggregate: aggregate2 };
        });
        updates.forEach(({ hash: hash2, store: store2, pageInfo: pageInfo2, aggregate: aggregate2 }) => {
          this.querySubs.set((prev) => {
            prev[hash2].result = { store: store2, pageInfo: pageInfo2, aggregate: aggregate2 };
            return prev;
          });
        });
        updates.forEach(({ hash: hash2 }) => {
          this.notifyOne(hash2);
        });
        break;
      case "transact-ok":
        const { "client-event-id": eventId, "tx-id": txId } = msg;
        const muts = this._rewriteMutations(this.attrs, this.pendingMutations.currentValue);
        const prevMutation = muts.get(eventId);
        if (!prevMutation) {
          break;
        }
        const mut = Object.assign(Object.assign({}, prevMutation), { "tx-id": txId });
        this.pendingMutations.set((prev) => {
          prev.set(eventId, mut);
          return prev;
        });
        this._finishTransaction("synced", eventId);
        const newAttrs = prevMutation["tx-steps"].filter(([action, ..._args]) => action === "add-attr").map(([_action, attr]) => attr).concat(Object.values(this.attrs));
        this._setAttrs(newAttrs);
        break;
      case "refresh-presence":
        const roomId = msg["room-id"];
        this._setPresencePeers(roomId, msg.data);
        this._notifyPresenceSubs(roomId);
        break;
      case "server-broadcast":
        const room = msg["room-id"];
        const topic = msg.topic;
        this._notifyBroadcastSubs(room, topic, msg);
        break;
      case "join-room-ok":
        const loadingRoomId = msg["room-id"];
        const joinedRoom = this._rooms[loadingRoomId];
        if (!joinedRoom) {
          if (this._roomsPendingLeave[roomId]) {
            this._tryLeaveRoom(loadingRoomId);
            delete this._roomsPendingLeave[roomId];
          }
          break;
        }
        joinedRoom.isConnected = true;
        this._notifyPresenceSubs(loadingRoomId);
        this._flushEnqueuedRoomData(loadingRoomId);
        break;
      case "join-room-error":
        const errorRoomId = msg["room-id"];
        const errorRoom = this._rooms[errorRoomId];
        if (errorRoom) {
          errorRoom.error = msg["error"];
        }
        this._notifyPresenceSubs(errorRoomId);
        break;
      case "error":
        this._handleReceiveError(msg);
        break;
      default:
        break;
    }
  }
  /**
   * @param {'timeout' | 'error'} status
   * @param {string} eventId
   * @param {{message?: string, hint?: string, error?: Error}} errDetails
   */
  _handleMutationError(status, eventId, errDetails) {
    const mut = this.pendingMutations.currentValue.get(eventId);
    if (mut && (status !== "timeout" || !mut["tx-id"])) {
      this.pendingMutations.set((prev) => {
        prev.delete(eventId);
        return prev;
      });
      this.notifyAll();
      this.notifyAttrsSubs();
      this.notifyMutationErrorSubs(errDetails);
      this._finishTransaction(status, eventId, errDetails);
    }
  }
  _handleReceiveError(msg) {
    var _a, _b, _c;
    const eventId = msg["client-event-id"];
    const prevMutation = this.pendingMutations.currentValue.get(eventId);
    const errorMessage = {
      message: msg.message || "Uh-oh, something went wrong. Ping Joe & Stopa."
    };
    if (prevMutation) {
      const errDetails = {
        message: msg.message,
        hint: msg.hint
      };
      this._handleMutationError("error", eventId, errDetails);
      return;
    }
    const q = msg.q || ((_a = msg["original-event"]) === null || _a === void 0 ? void 0 : _a.q);
    if (q) {
      const hash = weakHash_default(q);
      this.querySubs.set((prev) => {
        delete prev[hash];
        return prev;
      });
      this.notifyQueryError(weakHash_default(q), errorMessage);
      this.notifyQueryOnceError(hash, eventId, errorMessage);
      return;
    }
    const isInitError = ((_b = msg["original-event"]) === null || _b === void 0 ? void 0 : _b.op) === "init";
    if (isInitError) {
      if (msg.type === "record-not-found" && ((_c = msg.hint) === null || _c === void 0 ? void 0 : _c["record-type"]) === "app-user") {
        this.changeCurrentUser(null);
        return;
      }
      this._setStatus(STATUS.ERRORED, errorMessage);
      this.notifyAll();
      return;
    }
    const errorObj = Object.assign({}, msg);
    delete errorObj.message;
    delete errorObj.hint;
    console.error(msg.message, errorObj);
    if (msg.hint) {
      console.error("This error comes with some debugging information. Here it is: \n", msg.hint);
    }
  }
  notifyQueryOnceError(hash, eventId, e) {
    var _a;
    const r = (_a = this.queryOnceDfds[hash]) === null || _a === void 0 ? void 0 : _a.find((r2) => r2.eventId === eventId);
    if (!r)
      return;
    r.dfd.reject(e);
  }
  _setAttrs(attrs) {
    this.attrs = attrs.reduce((acc, attr) => {
      acc[attr.id] = attr;
      return acc;
    }, {});
    this.notifyAttrsSubs();
  }
  _startQuerySub(q, hash) {
    const eventId = uuid_default();
    this.querySubs.set((prev) => {
      prev[hash] = prev[hash] || { q, result: null, eventId };
      return prev;
    });
    this._trySendAuthed(eventId, { op: "add-query", q });
    return eventId;
  }
  /**
   *  When a user subscribes to a query the following side effects occur:
   *
   *  - We update querySubs to include the new query
   *  - We update queryCbs to include the new cb
   *  - If we already have a result for the query we call cb immediately
   *  - We send the server an `add-query` message
   *
   *  Returns an unsubscribe function
   */
  subscribeQuery(q, cb) {
    var _a;
    const hash = weakHash_default(q);
    const prevResult = this.getPreviousResult(q);
    if (prevResult) {
      cb(prevResult);
    }
    this.queryCbs[hash] = (_a = this.queryCbs[hash]) !== null && _a !== void 0 ? _a : [];
    this.queryCbs[hash].push({ q, cb });
    this._startQuerySub(q, hash);
    return () => {
      this._unsubQuery(q, hash, cb);
    };
  }
  queryOnce(q) {
    return __awaiter7(this, void 0, void 0, function* () {
      var _a;
      if (!this._isOnline) {
        throw new Error("Offline: Cannot execute query because the device is offline.");
      }
      const hash = weakHash_default(q);
      const dfd = new Deferred();
      const eventId = this._startQuerySub(q, hash);
      this.queryOnceDfds[hash] = (_a = this.queryOnceDfds[hash]) !== null && _a !== void 0 ? _a : [];
      this.queryOnceDfds[hash].push({ q, dfd, eventId });
      setTimeout(() => dfd.reject(new Error("Query timed out")), QUERY_ONCE_TIMEOUT);
      return dfd.promise;
    });
  }
  _completeQueryOnce(q, hash, dfd) {
    if (!this.queryOnceDfds[hash])
      return;
    this.queryOnceDfds[hash] = this.queryOnceDfds[hash].filter((r) => r.dfd !== dfd);
    this._cleanupQuery(q, hash);
  }
  _unsubQuery(q, hash, cb) {
    if (!this.queryCbs[hash])
      return;
    this.queryCbs[hash] = this.queryCbs[hash].filter((r) => r.cb !== cb);
    this._cleanupQuery(q, hash);
  }
  _cleanupQuery(q, hash) {
    var _a, _b;
    const hasListeners = ((_a = this.queryCbs[hash]) === null || _a === void 0 ? void 0 : _a.length) || ((_b = this.queryOnceDfds[hash]) === null || _b === void 0 ? void 0 : _b.length);
    if (hasListeners)
      return;
    delete this.queryCbs[hash];
    delete this.queryOnceDfds[hash];
    this._trySendAuthed(uuid_default(), { op: "remove-query", q });
  }
  // When we `pushTx`, it's possible that we don't yet have `this.attrs`
  // This means that `tx-steps` in `pendingMutations` will include `add-attr`
  // commands for attrs that already exist.
  //
  // This will also affect `add-triple` and `retract-triple` which
  // reference attr-ids that do not match the server.
  //
  // We fix this by rewriting `tx-steps` in each `pendingMutation`.
  // We remove `add-attr` commands for attrs that already exist.
  // We update `add-triple` and `retract-triple` commands to use the
  // server attr-ids.
  _rewriteMutations(attrs, muts) {
    if (!attrs)
      return muts;
    const findExistingAttr = (attr) => {
      const [_, etype, label] = attr["forward-identity"];
      const existing = getAttrByFwdIdentName(attrs, etype, label);
      return existing;
    };
    const findReverseAttr = (attr) => {
      const [_, etype, label] = attr["forward-identity"];
      const revAttr = getAttrByReverseIdentName(attrs, etype, label);
      return revAttr;
    };
    const mapping = { attrIdMap: {}, refSwapAttrIds: /* @__PURE__ */ new Set() };
    const rewriteTxSteps = (txSteps) => {
      const retTxSteps = [];
      for (const txStep of txSteps) {
        const [action] = txStep;
        if (action === "add-attr") {
          const [_action, attr] = txStep;
          const existing = findExistingAttr(attr);
          if (existing) {
            mapping.attrIdMap[attr.id] = existing.id;
            continue;
          }
          if (attr["value-type"] === "ref") {
            const revAttr = findReverseAttr(attr);
            if (revAttr) {
              mapping.attrIdMap[attr.id] = revAttr.id;
              mapping.refSwapAttrIds.add(attr.id);
              continue;
            }
          }
        }
        const newTxStep = rewriteStep(mapping, txStep);
        retTxSteps.push(newTxStep);
      }
      return retTxSteps;
    };
    const rewritten = /* @__PURE__ */ new Map();
    for (const [k, mut] of muts.entries()) {
      rewritten.set(k, Object.assign(Object.assign({}, mut), { "tx-steps": rewriteTxSteps(mut["tx-steps"]) }));
    }
    return rewritten;
  }
  // ---------------------------
  // Transact
  optimisticAttrs() {
    var _a;
    const pendingMutationSteps = [
      ...this.pendingMutations.currentValue.values()
    ].flatMap((x) => x["tx-steps"]);
    const deletedAttrIds = new Set(pendingMutationSteps.filter(([action, _attr]) => action === "delete-attr").map(([_action, id2]) => id2));
    const pendingAttrs = [];
    for (const [_action, attr] of pendingMutationSteps) {
      if (_action === "add-attr") {
        pendingAttrs.push(attr);
      } else if (_action === "update-attr" && attr.id && ((_a = this.attrs) === null || _a === void 0 ? void 0 : _a[attr.id])) {
        const fullAttr = Object.assign(Object.assign({}, this.attrs[attr.id]), attr);
        pendingAttrs.push(fullAttr);
      }
    }
    const attrsWithoutDeleted = [
      ...Object.values(this.attrs || {}),
      ...pendingAttrs
    ].filter((a) => !deletedAttrIds.has(a.id));
    const attrsRecord = Object.fromEntries(attrsWithoutDeleted.map((a) => [a.id, a]));
    return attrsRecord;
  }
  /** Runs instaql on a query and a store */
  dataForQuery(hash) {
    const errorMessage = this._errorMessage;
    if (errorMessage) {
      return { error: errorMessage };
    }
    if (!this.querySubs)
      return;
    if (!this.pendingMutations)
      return;
    const querySubVersion = this.querySubs.version();
    const querySubs = this.querySubs.currentValue;
    const pendingMutationsVersion = this.pendingMutations.version();
    const pendingMutations = this.pendingMutations.currentValue;
    const { q, result } = querySubs[hash] || {};
    if (!result)
      return;
    const cached = this._dataForQueryCache[hash];
    if (cached && querySubVersion === cached.querySubVersion && pendingMutationsVersion === cached.pendingMutationsVersion) {
      return cached.data;
    }
    const { store, pageInfo, aggregate } = result;
    const muts = this._rewriteMutations(store.attrs, pendingMutations);
    const txSteps = [...muts.values()].flatMap((x) => x["tx-steps"]);
    const newStore = transact(store, txSteps);
    const resp = query2({ store: newStore, pageInfo, aggregate }, q);
    this._dataForQueryCache[hash] = {
      querySubVersion,
      pendingMutationsVersion,
      data: resp
    };
    return resp;
  }
  /** Re-compute all subscriptions */
  notifyAll() {
    Object.keys(this.queryCbs).forEach((hash) => {
      this.notifyOne(hash);
    });
  }
  loadedNotifyAll() {
    if (this.pendingMutations.isLoading() || this.querySubs.isLoading())
      return;
    this.notifyAll();
  }
  shutdown() {
    this._isShutdown = true;
    this._ws.close();
  }
  /**
   * Sends mutation to server and schedules a timeout to cancel it if
   * we don't hear back in time.
   * Note: If we're offline we don't schedule a timeout, we'll schedule it
   * later once we're back online and send the mutation again
   *
   */
  _sendMutation(eventId, mutation) {
    if (mutation.error) {
      this._handleMutationError("error", eventId, {
        error: mutation.error,
        message: mutation.error.message
      });
      return;
    }
    if (this.status !== STATUS.AUTHENTICATED) {
      this._finishTransaction("enqueued", eventId);
      return;
    }
    const timeoutMs = Math.max(5e3, this.pendingMutations.currentValue.size * 5e3);
    if (!this._isOnline) {
      this._finishTransaction("enqueued", eventId);
    } else {
      this._trySend(eventId, mutation);
      setTimeout(() => {
        this._finishTransaction("pending", eventId);
      }, 3e3);
      setTimeout(() => {
        if (!this._isOnline) {
          return;
        }
        this._handleMutationError("timeout", eventId, {
          message: "transaction timed out"
        });
      }, timeoutMs);
    }
  }
  // ---------------------------
  // Websocket
  /** Send messages we accumulated while we were connecting */
  _flushPendingMessages() {
    const subs = Object.keys(this.queryCbs).map((hash) => {
      return this.querySubs.currentValue[hash];
    });
    const safeSubs = subs.filter((x) => x);
    safeSubs.forEach(({ eventId, q }) => {
      this._trySendAuthed(eventId, { op: "add-query", q });
    });
    Object.values(this.queryOnceDfds).flat().forEach(({ eventId, q }) => {
      this._trySendAuthed(eventId, { op: "add-query", q });
    });
    const muts = this._rewriteMutations(this.attrs, this.pendingMutations.currentValue);
    muts.forEach((mut, eventId) => {
      if (!mut["tx-id"]) {
        this._sendMutation(eventId, mut);
      }
    });
  }
  _trySendAuthed(eventId, msg) {
    if (this.status !== STATUS.AUTHENTICATED) {
      return;
    }
    this._trySend(eventId, msg);
  }
  _trySend(eventId, msg) {
    if (this._ws.readyState !== WS_OPEN_STATUS) {
      return;
    }
    this._ws.send(JSON.stringify(Object.assign({ "client-event-id": eventId }, msg)));
  }
  _ensurePreviousSocketClosed() {
    if (this._ws && this._ws.readyState === WS_OPEN_STATUS) {
      this._isManualClose = true;
      this._ws.close();
    }
  }
  _startSocket() {
    this._ensurePreviousSocketClosed();
    this._ws = new WebSocket(`${this.config.websocketURI}?app_id=${this.config.appId}`);
    this._ws.onopen = this._wsOnOpen;
    this._ws.onmessage = this._wsOnMessage;
    this._ws.onclose = this._wsOnClose;
  }
  /**
   * Given a key, returns a stable local id, unique to this device and app.
   *
   * This can be useful if you want to create guest ids for example.
   *
   * Note: If the user deletes their local storage, this id will change.
   *
   * We use this._localIdPromises to ensure that we only generate a local
   * id once, even if multiple callers call this function concurrently.
   */
  getLocalId(name) {
    return __awaiter7(this, void 0, void 0, function* () {
      const k = `localToken_${name}`;
      const id2 = yield this._persister.getItem(k);
      if (id2)
        return id2;
      if (this._localIdPromises[k]) {
        return this._localIdPromises[k];
      }
      const newId = uuid_default();
      this._localIdPromises[k] = this._persister.setItem(k, newId).then(() => newId);
      return this._localIdPromises[k];
    });
  }
  // ----
  // Auth
  _replaceUrlAfterOAuth() {
    if (typeof URL === "undefined") {
      return;
    }
    const url = new URL(window.location.href);
    if (url.searchParams.get(OAUTH_REDIRECT_PARAM)) {
      const startUrl = url.toString();
      url.searchParams.delete(OAUTH_REDIRECT_PARAM);
      url.searchParams.delete("code");
      url.searchParams.delete("error");
      const newPath = url.pathname + (url.searchParams.size ? "?" + url.searchParams : "") + url.hash;
      history.replaceState(history.state, "", newPath);
      if (
        // @ts-ignore (waiting for ts support)
        typeof navigation === "object" && // @ts-ignore (waiting for ts support)
        typeof navigation.addEventListener === "function" && // @ts-ignore (waiting for ts support)
        typeof navigation.removeEventListener === "function"
      ) {
        let ran = false;
        const listener = (e) => {
          var _a;
          if (!ran) {
            ran = true;
            navigation.removeEventListener("navigate", listener);
            if (!e.userInitiated && e.navigationType === "replace" && ((_a = e.destination) === null || _a === void 0 ? void 0 : _a.url) === startUrl) {
              history.replaceState(history.state, "", newPath);
            }
          }
        };
        navigation.addEventListener("navigate", listener);
      }
    }
  }
  /**
   *
   * @returns Promise<null | {error: {message: string}}>
   */
  _oauthLoginInit() {
    return __awaiter7(this, void 0, void 0, function* () {
      var _a, _b, _c, _d;
      if (typeof window === "undefined" || typeof window.location === "undefined" || typeof URLSearchParams === "undefined") {
        return null;
      }
      const params = new URLSearchParams(window.location.search);
      if (!params.get(OAUTH_REDIRECT_PARAM)) {
        return null;
      }
      const error = params.get("error");
      if (error) {
        this._replaceUrlAfterOAuth();
        return { error: { message: error } };
      }
      const code = params.get("code");
      if (!code) {
        return null;
      }
      this._replaceUrlAfterOAuth();
      try {
        const { user } = yield exchangeCodeForToken({
          apiURI: this.config.apiURI,
          appId: this.config.appId,
          code
        });
        this.setCurrentUser(user);
        return null;
      } catch (e) {
        if (((_a = e === null || e === void 0 ? void 0 : e.body) === null || _a === void 0 ? void 0 : _a.type) === "record-not-found" && ((_c = (_b = e === null || e === void 0 ? void 0 : e.body) === null || _b === void 0 ? void 0 : _b.hint) === null || _c === void 0 ? void 0 : _c["record-type"]) === "app-oauth-code" && (yield this._hasCurrentUser())) {
          return null;
        }
        const message = ((_d = e === null || e === void 0 ? void 0 : e.body) === null || _d === void 0 ? void 0 : _d.message) || "Error logging in.";
        return { error: { message } };
      }
    });
  }
  _waitForOAuthCallbackResponse() {
    return __awaiter7(this, void 0, void 0, function* () {
      return yield this._oauthCallbackResponse;
    });
  }
  __subscribeMutationErrors(cb) {
    this.mutationErrorCbs.push(cb);
    return () => {
      this.mutationErrorCbs = this.mutationErrorCbs.filter((x) => x !== cb);
    };
  }
  subscribeAuth(cb) {
    this.authCbs.push(cb);
    const currUserCached = this._currentUserCached;
    if (!currUserCached.isLoading) {
      cb(this._currentUserCached);
    }
    let unsubbed = false;
    this.getCurrentUser().then((resp) => {
      if (unsubbed)
        return;
      if (areObjectsDeepEqual(resp, currUserCached))
        return;
      cb(resp);
    });
    return () => {
      unsubbed = true;
      this.authCbs = this.authCbs.filter((x) => x !== cb);
    };
  }
  subscribeAttrs(cb) {
    this.attrsCbs.push(cb);
    if (this.attrs) {
      cb(this.attrs);
    }
    return () => {
      this.attrsCbs = this.attrsCbs.filter((x) => x !== cb);
    };
  }
  notifyAuthSubs(user) {
    this.authCbs.forEach((cb) => cb(user));
  }
  notifyMutationErrorSubs(error) {
    this.mutationErrorCbs.forEach((cb) => cb(error));
  }
  notifyAttrsSubs() {
    if (!this.attrs)
      return;
    const oas = this.optimisticAttrs();
    this.attrsCbs.forEach((cb) => cb(oas));
  }
  setCurrentUser(user) {
    return __awaiter7(this, void 0, void 0, function* () {
      yield this._persister.setItem(currentUserKey, JSON.stringify(user));
    });
  }
  getCurrentUserCached() {
    return this._currentUserCached;
  }
  getCurrentUser() {
    return __awaiter7(this, void 0, void 0, function* () {
      const oauthResp = yield this._waitForOAuthCallbackResponse();
      if (oauthResp === null || oauthResp === void 0 ? void 0 : oauthResp.error) {
        const errorV = { error: oauthResp.error, user: void 0 };
        this._currentUserCached = Object.assign({ isLoading: false }, errorV);
        return errorV;
      }
      const user = yield this._persister.getItem(currentUserKey);
      const userV = { user: JSON.parse(user), error: void 0 };
      this._currentUserCached = Object.assign({ isLoading: false }, userV);
      return userV;
    });
  }
  _hasCurrentUser() {
    return __awaiter7(this, void 0, void 0, function* () {
      const user = yield this._persister.getItem(currentUserKey);
      return JSON.parse(user) != null;
    });
  }
  changeCurrentUser(newUser) {
    return __awaiter7(this, void 0, void 0, function* () {
      var _a;
      const { user: oldUser } = yield this.getCurrentUser();
      if (areObjectsDeepEqual(oldUser, newUser)) {
        return;
      }
      yield this.setCurrentUser(newUser);
      this.updateUser(newUser);
      try {
        (_a = this._broadcastChannel) === null || _a === void 0 ? void 0 : _a.postMessage({ type: "auth" });
      } catch (error) {
        console.error("Error posting message to broadcast channel", error);
      }
    });
  }
  updateUser(newUser) {
    const newV = { error: void 0, user: newUser };
    this._currentUserCached = Object.assign({ isLoading: false }, newV);
    this.querySubs.set((prev) => {
      Object.keys(prev).forEach((k) => {
        delete prev[k].result;
      });
      return prev;
    });
    this._reconnectTimeoutMs = 0;
    this._ws.close();
    this._oauthCallbackResponse = null;
    this.notifyAuthSubs(newV);
  }
  sendMagicCode({ email }) {
    return sendMagicCode({
      apiURI: this.config.apiURI,
      appId: this.config.appId,
      email
    });
  }
  signInWithMagicCode(_a) {
    return __awaiter7(this, arguments, void 0, function* ({ email, code }) {
      const res = yield verifyMagicCode({
        apiURI: this.config.apiURI,
        appId: this.config.appId,
        email,
        code
      });
      this.changeCurrentUser(res.user);
      return res;
    });
  }
  signInWithCustomToken(authToken) {
    return __awaiter7(this, void 0, void 0, function* () {
      const res = yield verifyRefreshToken({
        apiURI: this.config.apiURI,
        appId: this.config.appId,
        refreshToken: authToken
      });
      this.changeCurrentUser(res.user);
    });
  }
  signOut() {
    return __awaiter7(this, void 0, void 0, function* () {
      var _a;
      const currentUser = yield this.getCurrentUser();
      const refreshToken = (_a = currentUser === null || currentUser === void 0 ? void 0 : currentUser.user) === null || _a === void 0 ? void 0 : _a.refresh_token;
      if (refreshToken) {
        try {
          yield signOut({
            apiURI: this.config.apiURI,
            appId: this.config.appId,
            refreshToken
          });
        } catch (e) {
        }
      }
      this.changeCurrentUser(null);
    });
  }
  /**
   * Creates an OAuth authorization URL.
   * @param {Object} params - The parameters to create the authorization URL.
   * @param {string} params.clientName - The name of the client requesting authorization.
   * @param {string} params.redirectURL - The URL to redirect users to after authorization.
   * @returns {string} The created authorization URL.
   */
  createAuthorizationURL({ clientName, redirectURL }) {
    const { apiURI, appId } = this.config;
    return `${apiURI}/runtime/oauth/start?app_id=${appId}&client_name=${clientName}&redirect_uri=${redirectURL}`;
  }
  exchangeCodeForToken(_a) {
    return __awaiter7(this, arguments, void 0, function* ({ code, codeVerifier }) {
      const res = yield exchangeCodeForToken({
        apiURI: this.config.apiURI,
        appId: this.config.appId,
        code,
        codeVerifier
      });
      this.changeCurrentUser(res.user);
      return res;
    });
  }
  issuerURI() {
    const { apiURI, appId } = this.config;
    return `${apiURI}/runtime/${appId}`;
  }
  /**
   * @param {Object} params
   * @param {string} params.clientName - The name of the client requesting authorization.
   * @param {string} params.idToken - The id_token from the external service
   * @param {string | null | undefined} [params.nonce] - The nonce used when requesting the id_token from the external service
   */
  signInWithIdToken(_a) {
    return __awaiter7(this, arguments, void 0, function* ({ idToken, clientName, nonce }) {
      var _b;
      const currentUser = yield this.getCurrentUser();
      const refreshToken = (_b = currentUser === null || currentUser === void 0 ? void 0 : currentUser.user) === null || _b === void 0 ? void 0 : _b.refresh_token;
      const res = yield signInWithIdToken({
        apiURI: this.config.apiURI,
        appId: this.config.appId,
        idToken,
        clientName,
        nonce,
        refreshToken
      });
      this.changeCurrentUser(res.user);
      return res;
    });
  }
  // --------
  // Rooms
  joinRoom(roomId) {
    if (!this._rooms[roomId]) {
      this._rooms[roomId] = {
        isConnected: false,
        error: void 0
      };
    }
    this._tryJoinRoom(roomId);
    return () => {
      this._cleanupRoom(roomId);
    };
  }
  _cleanupRoom(roomId) {
    var _a, _b, _c, _d;
    if (!((_b = (_a = this._presence[roomId]) === null || _a === void 0 ? void 0 : _a.handlers) === null || _b === void 0 ? void 0 : _b.length) && !Object.keys((_c = this._broadcastSubs[roomId]) !== null && _c !== void 0 ? _c : {}).length) {
      const isConnected = (_d = this._rooms[roomId]) === null || _d === void 0 ? void 0 : _d.isConnected;
      delete this._rooms[roomId];
      delete this._presence[roomId];
      delete this._broadcastSubs[roomId];
      if (isConnected) {
        this._tryLeaveRoom(roomId);
      } else {
        this._roomsPendingLeave[roomId] = true;
      }
    }
  }
  // --------
  // Presence
  /**
   * @template {keyof RoomSchema} RoomType
   * @template {keyof RoomSchema[RoomType]['presence']} Keys
   * @param {RoomType} roomType
   * @param {string | number} roomId
   * @param {import('./presence').PresenceOpts<RoomSchema[RoomType]['presence'], Keys>} opts
   * @returns {import('./presence').PresenceResponse<RoomSchema[RoomType]['presence'], Keys>}
   */
  getPresence(roomType, roomId, opts = {}) {
    const room = this._rooms[roomId];
    const presence = this._presence[roomId];
    if (!room || !presence || !presence.result)
      return null;
    return Object.assign(Object.assign({}, buildPresenceSlice(presence.result, opts, this._sessionId)), { isLoading: !room.isConnected, error: room.error });
  }
  /**
   * @template {keyof RoomSchema} RoomType
   * @param {RoomType} roomType
   * @param {string | number} roomId
   * @param {Partial<RoomSchema[RoomType]['presence']>} partialData
   */
  publishPresence(roomType, roomId, partialData) {
    const room = this._rooms[roomId];
    const presence = this._presence[roomId];
    if (!room || !presence) {
      return;
    }
    presence.result = presence.result || {};
    const data = Object.assign(Object.assign({}, presence.result.user), partialData);
    presence.result.user = data;
    if (!room.isConnected) {
      return;
    }
    this._trySetPresence(roomId, data);
    this._notifyPresenceSubs(roomId);
  }
  _trySetPresence(roomId, data) {
    this._trySendAuthed(uuid_default(), {
      op: "set-presence",
      "room-id": roomId,
      data
    });
  }
  _tryJoinRoom(roomId) {
    this._trySendAuthed(uuid_default(), { op: "join-room", "room-id": roomId });
    delete this._roomsPendingLeave[roomId];
  }
  _tryLeaveRoom(roomId) {
    this._trySendAuthed(uuid_default(), { op: "leave-room", "room-id": roomId });
  }
  /**
   * @template {keyof RoomSchema} RoomType
   * @template {keyof RoomSchema[RoomType]['presence']} Keys
   * @param {RoomType} roomType
   * @param {string | number} roomId
   * @param {import('./presence').PresenceOpts<RoomSchema[RoomType]['presence'], Keys>} opts
   * @param {(slice: import('./presence').PresenceResponse<RoomSchema[RoomType]['presence'], Keys>) => void} cb
   * @returns {() => void}
   */
  subscribePresence(roomType, roomId, opts, cb) {
    const leaveRoom = this.joinRoom(roomId);
    const handler = Object.assign(Object.assign({}, opts), { roomId, cb, prev: null });
    this._presence[roomId] = this._presence[roomId] || {};
    this._presence[roomId].handlers = this._presence[roomId].handlers || [];
    this._presence[roomId].handlers.push(handler);
    this._notifyPresenceSub(roomId, handler);
    return () => {
      var _a, _b, _c;
      this._presence[roomId].handlers = (_c = (_b = (_a = this._presence[roomId]) === null || _a === void 0 ? void 0 : _a.handlers) === null || _b === void 0 ? void 0 : _b.filter((x) => x !== handler)) !== null && _c !== void 0 ? _c : [];
      leaveRoom();
    };
  }
  _notifyPresenceSubs(roomId) {
    var _a, _b;
    (_b = (_a = this._presence[roomId]) === null || _a === void 0 ? void 0 : _a.handlers) === null || _b === void 0 ? void 0 : _b.forEach((handler) => {
      this._notifyPresenceSub(roomId, handler);
    });
  }
  _notifyPresenceSub(roomId, handler) {
    const slice = this.getPresence("", roomId, handler);
    if (!slice) {
      return;
    }
    if (handler.prev && !hasPresenceResponseChanged(slice, handler.prev)) {
      return;
    }
    handler.prev = slice;
    handler.cb(slice);
  }
  _setPresencePeers(roomId, data) {
    const sessions = Object.assign({}, data);
    delete sessions[this._sessionId];
    const peers = Object.fromEntries(Object.entries(sessions).map(([k, v]) => [k, v.data]));
    this._presence[roomId] = this._presence[roomId] || {};
    this._presence[roomId].result = this._presence[roomId].result || {};
    this._presence[roomId].result.peers = peers;
  }
  // --------
  // Broadcast
  publishTopic({ roomType, roomId, topic, data }) {
    var _a;
    const room = this._rooms[roomId];
    if (!room) {
      return;
    }
    if (!room.isConnected) {
      this._broadcastQueue[roomId] = (_a = this._broadcastQueue[roomId]) !== null && _a !== void 0 ? _a : [];
      this._broadcastQueue[roomId].push({ topic, roomType, data });
      return;
    }
    this._tryBroadcast(roomId, roomType, topic, data);
  }
  _tryBroadcast(roomId, roomType, topic, data) {
    this._trySendAuthed(uuid_default(), {
      op: "client-broadcast",
      "room-id": roomId,
      roomType,
      topic,
      data
    });
  }
  subscribeTopic(roomId, topic, cb) {
    const leaveRoom = this.joinRoom(roomId);
    this._broadcastSubs[roomId] = this._broadcastSubs[roomId] || {};
    this._broadcastSubs[roomId][topic] = this._broadcastSubs[roomId][topic] || [];
    this._broadcastSubs[roomId][topic].push(cb);
    this._presence[roomId] = this._presence[roomId] || {};
    return () => {
      this._broadcastSubs[roomId][topic] = this._broadcastSubs[roomId][topic].filter((x) => x !== cb);
      if (!this._broadcastSubs[roomId][topic].length) {
        delete this._broadcastSubs[roomId][topic];
      }
      leaveRoom();
    };
  }
  _notifyBroadcastSubs(room, topic, msg) {
    var _a, _b, _c;
    (_c = (_b = (_a = this._broadcastSubs) === null || _a === void 0 ? void 0 : _a[room]) === null || _b === void 0 ? void 0 : _b[topic]) === null || _c === void 0 ? void 0 : _c.forEach((cb) => {
      var _a2, _b2, _c2, _d, _e, _f;
      const data = (_a2 = msg.data) === null || _a2 === void 0 ? void 0 : _a2.data;
      const peer = msg.data["peer-id"] === this._sessionId ? (_c2 = (_b2 = this._presence[room]) === null || _b2 === void 0 ? void 0 : _b2.result) === null || _c2 === void 0 ? void 0 : _c2.user : (_f = (_e = (_d = this._presence[room]) === null || _d === void 0 ? void 0 : _d.result) === null || _e === void 0 ? void 0 : _e.peers) === null || _f === void 0 ? void 0 : _f[msg.data["peer-id"]];
      return cb(data, peer);
    });
  }
  // --------
  // Storage
  upload(path, file) {
    return __awaiter7(this, void 0, void 0, function* () {
      var _a;
      const currentUser = yield this.getCurrentUser();
      const refreshToken = (_a = currentUser === null || currentUser === void 0 ? void 0 : currentUser.user) === null || _a === void 0 ? void 0 : _a.refresh_token;
      const fileName = path || file.name;
      const url = yield getSignedUploadUrl({
        apiURI: this.config.apiURI,
        appId: this.config.appId,
        fileName,
        refreshToken
      });
      const isSuccess = yield upload(url, file);
      return isSuccess;
    });
  }
  getDownloadUrl(path) {
    return __awaiter7(this, void 0, void 0, function* () {
      var _a;
      const currentUser = yield this.getCurrentUser();
      const refreshToken = (_a = currentUser === null || currentUser === void 0 ? void 0 : currentUser.user) === null || _a === void 0 ? void 0 : _a.refresh_token;
      const url = yield getDownloadUrl({
        apiURI: this.config.apiURI,
        appId: this.config.appId,
        path,
        refreshToken
      });
      return url;
    });
  }
  deleteFile(path) {
    return __awaiter7(this, void 0, void 0, function* () {
      var _a;
      const currentUser = yield this.getCurrentUser();
      const refreshToken = (_a = currentUser === null || currentUser === void 0 ? void 0 : currentUser.user) === null || _a === void 0 ? void 0 : _a.refresh_token;
      const result = yield deleteFile({
        apiURI: this.config.apiURI,
        appId: this.config.appId,
        path,
        refreshToken
      });
      return result;
    });
  }
};

// ../node_modules/@instantdb/core/dist/module/schemaTypes.js
var DataAttrDef = class _DataAttrDef {
  constructor(valueType, required, config = { indexed: false, unique: false }) {
    this.valueType = valueType;
    this.required = required;
    this.config = config;
  }
  optional() {
    return new _DataAttrDef(this.valueType, false);
  }
  unique() {
    return new _DataAttrDef(this.valueType, this.required, Object.assign(Object.assign({}, this.config), { unique: true }));
  }
  indexed() {
    return new _DataAttrDef(this.valueType, this.required, Object.assign(Object.assign({}, this.config), { indexed: true }));
  }
};
var InstantGraph = class _InstantGraph {
  constructor(entities, links) {
    this.entities = entities;
    this.links = links;
  }
  withRoomSchema() {
    return new _InstantGraph(this.entities, this.links);
  }
};
var EntityDef = class _EntityDef {
  constructor(attrs, links) {
    this.attrs = attrs;
    this.links = links;
  }
  asType() {
    return new _EntityDef(this.attrs, this.links);
  }
};

// ../node_modules/@instantdb/core/dist/module/schema.js
function graph(entities, links) {
  return new InstantGraph(
    enrichEntitiesWithLinks(entities, links),
    // (XXX): LinksDef<any> stems from TypeScript’s inability to reconcile the
    // type EntitiesWithLinks<EntitiesWithoutLinks, Links> with
    // EntitiesWithoutLinks. TypeScript is strict about ensuring that types are
    // correctly aligned and does not allow for substituting a type that might
    // be broader or have additional properties.
    links
  );
}
function entity(attrs) {
  return new EntityDef(attrs, {});
}
function string() {
  return new DataAttrDef("string", true);
}
function number() {
  return new DataAttrDef("number", true);
}
function boolean() {
  return new DataAttrDef("boolean", true);
}
function json() {
  return new DataAttrDef("json", true);
}
function any() {
  return new DataAttrDef("json", true);
}
function enrichEntitiesWithLinks(entities, links) {
  var _a, _b, _c, _d;
  const linksIndex = { fwd: {}, rev: {} };
  for (const linkDef of Object.values(links)) {
    (_a = linksIndex.fwd)[_b = linkDef.forward.on] || (_a[_b] = {});
    (_c = linksIndex.rev)[_d = linkDef.reverse.on] || (_c[_d] = {});
    linksIndex.fwd[linkDef.forward.on][linkDef.forward.label] = {
      entityName: linkDef.reverse.on,
      cardinality: linkDef.forward.has
    };
    linksIndex.rev[linkDef.reverse.on][linkDef.reverse.label] = {
      entityName: linkDef.forward.on,
      cardinality: linkDef.reverse.has
    };
  }
  const enrichedEntities = Object.fromEntries(Object.entries(entities).map(([name, def]) => [
    name,
    new EntityDef(def.attrs, Object.assign(Object.assign({}, linksIndex.fwd[name]), linksIndex.rev[name]))
  ]));
  return enrichedEntities;
}
var i = {
  // constructs
  graph,
  entity,
  // value types
  string,
  number,
  boolean,
  json,
  any
};

// ../node_modules/@instantdb/core/dist/module/devtool.js
var currentDevtool;
function createDevtool(appId) {
  currentDevtool === null || currentDevtool === void 0 ? void 0 : currentDevtool.dispose();
  const container = createContainer();
  const toggler = createToggler(toggleView);
  const iframe = createIframe(getSrc(appId));
  function onPostMessage(event) {
    var _a;
    if (event.source !== iframe.element.contentWindow)
      return;
    if (((_a = event.data) === null || _a === void 0 ? void 0 : _a.type) === "close" && container.isVisible()) {
      toggleView();
    }
  }
  function onKeyDown(event) {
    const isToggleShortcut = event.shiftKey && event.ctrlKey && event.key === "0";
    const isEsc = event.key === "Escape" || event.key === "Esc";
    if (isToggleShortcut || isEsc) {
      toggleView();
    }
  }
  function toggleView() {
    if (container.isVisible()) {
      container.element.style.display = "none";
    } else {
      container.element.style.display = "block";
      if (!container.element.contains(iframe.element)) {
        container.element.appendChild(iframe.element);
      }
    }
  }
  function dispose() {
    container.element.remove();
    toggler.element.remove();
    removeEventListener("keydown", onKeyDown);
    removeEventListener("message", onPostMessage);
  }
  function create2() {
    document.body.appendChild(container.element);
    document.body.appendChild(toggler.element);
    addEventListener("keydown", onKeyDown);
    addEventListener("message", onPostMessage);
    currentDevtool = {
      dispose
    };
  }
  return create2();
}
function getSrc(appId) {
  const isDev = window.DEV_DEVTOOL;
  const src = `${isDev ? "http://localhost:3000" : "https://instantdb.com"}/_devtool?appId=${appId}`;
  return src;
}
function createIframe(src) {
  const element = document.createElement("iframe");
  element.src = src;
  Object.assign(element.style, {
    width: "100%",
    height: "100%",
    borderRadius: "4px",
    backgroundColor: "white",
    border: "none"
  });
  return { element };
}
function createToggler(onClick) {
  const logoSVG = `
    <svg width="32" height="32" viewBox="0 0 512 512" fill="none" xmlns="http://www.w3.org/2000/svg">
      <rect width="512" height="512" fill="black"/>
      <rect x="97.0973" y="91.3297" width="140" height="330" fill="white"/>
    </svg>
  `;
  const element = document.createElement("button");
  element.innerHTML = logoSVG;
  Object.assign(element.style, {
    // pos
    position: "fixed",
    bottom: "24px",
    left: "24px",
    height: "32px",
    width: "32px",
    // layout
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    // look
    padding: "0",
    margin: "0",
    border: "none",
    cursor: "pointer"
  });
  element.addEventListener("click", onClick);
  return { element };
}
function createContainer() {
  const element = document.createElement("div");
  Object.assign(element.style, {
    position: "fixed",
    bottom: "24px",
    right: "24px",
    left: "60px",
    top: "72px",
    display: "block",
    borderRadius: "4px",
    border: "1px #ccc solid",
    boxShadow: "0px 0px 8px #00000044",
    backgroundColor: "#eee",
    zIndex: "999990"
  });
  element.style.display = "none";
  function isVisible() {
    return element.style.display !== "none";
  }
  return { element, isVisible };
}

// ../node_modules/@instantdb/core/dist/module/index.js
var defaultOpenDevtool = true;
var defaultConfig2 = {
  apiURI: "https://api.instantdb.com",
  websocketURI: "wss://api.instantdb.com/runtime/session"
};
function initGlobalInstantCoreStore() {
  var _a;
  globalThis.__instantDbStore = (_a = globalThis.__instantDbStore) !== null && _a !== void 0 ? _a : {};
  return globalThis.__instantDbStore;
}
var globalInstantCoreStore = initGlobalInstantCoreStore();
function _init_internal(config, Storage2, NetworkListener) {
  const existingClient = globalInstantCoreStore[config.appId];
  if (existingClient) {
    return existingClient;
  }
  const reactor = new Reactor(Object.assign(Object.assign({}, defaultConfig2), config), Storage2 || IndexedDBStorage, NetworkListener || WindowNetworkListener);
  const client = new InstantCore(reactor);
  globalInstantCoreStore[config.appId] = client;
  if (typeof window !== "undefined" && typeof window.location !== "undefined") {
    const showDevtool = (
      // show widget by default?
      ("devtool" in config ? Boolean(config.devtool) : defaultOpenDevtool) && // only run on localhost (dev env)
      window.location.hostname === "localhost" && // used by dash and other internal consumers
      !Boolean(globalThis._nodevtool)
    );
    if (showDevtool) {
      createDevtool(config.appId);
    }
  }
  return client;
}
var InstantCore = class {
  constructor(reactor) {
    this.tx = txInit();
    this._reactor = reactor;
    this.auth = new Auth(this._reactor);
    this.storage = new Storage(this._reactor);
  }
  /**
   * Use this to write data! You can create, update, delete, and link objects
   *
   * @see https://instantdb.com/docs/instaml
   *
   * @example
   *   // Create a new object in the `goals` namespace
   *   const goalId = id();
   *   db.transact(tx.goals[goalId].update({title: "Get fit"}))
   *
   *   // Update the title
   *   db.transact(tx.goals[goalId].update({title: "Get super fit"}))
   *
   *   // Delete it
   *   db.transact(tx.goals[goalId].delete())
   *
   *   // Or create an association:
   *   todoId = id();
   *   db.transact([
   *    tx.todos[todoId].update({ title: 'Go on a run' }),
   *    tx.goals[goalId].link({todos: todoId}),
   *  ])
   */
  transact(chunks) {
    return this._reactor.pushTx(chunks);
  }
  getLocalId(name) {
    return this._reactor.getLocalId(name);
  }
  /**
   * Use this to query your data!
   *
   * @see https://instantdb.com/docs/instaql
   *
   * @example
   *  // listen to all goals
   *  db.subscribeQuery({ goals: {} }, (resp) => {
   *    console.log(resp.data.goals)
   *  })
   *
   *  // goals where the title is "Get Fit"
   *  db.subscribeQuery(
   *    { goals: { $: { where: { title: "Get Fit" } } } },
   *    (resp) => {
   *      console.log(resp.data.goals)
   *    }
   *  )
   *
   *  // all goals, _alongside_ their todos
   *  db.subscribeQuery({ goals: { todos: {} } }, (resp) => {
   *    console.log(resp.data.goals)
   *  });
   */
  subscribeQuery(query3, cb) {
    return this._reactor.subscribeQuery(query3, cb);
  }
  /**
   * Listen for the logged in state. This is useful
   * for deciding when to show a login screen.
   *
   * @see https://instantdb.com/docs/auth
   * @example
   *   const unsub = db.subscribeAuth((auth) => {
   *     if (auth.user) {
   *     console.log('logged in as', auth.user.email)
   *    } else {
   *      console.log('logged out')
   *    }
   *  })
   */
  subscribeAuth(cb) {
    return this._reactor.subscribeAuth(cb);
  }
  /**
   * Join a room to publish and subscribe to topics and presence.
   *
   * @see https://instantdb.com/docs/presence-and-topics
   * @example
   * // init
   * const db = init();
   * const room = db.joinRoom(roomType, roomId);
   * // usage
   * const unsubscribeTopic = room.subscribeTopic("foo", console.log);
   * const unsubscribePresence = room.subscribePresence({}, console.log);
   * room.publishTopic("hello", { message: "hello world!" });
   * room.publishPresence({ name: "joe" });
   * // later
   * unsubscribePresence();
   * unsubscribeTopic();
   * room.leaveRoom();
   */
  joinRoom(roomType = "_defaultRoomType", roomId = "_defaultRoomId") {
    const leaveRoom = this._reactor.joinRoom(roomId);
    return {
      leaveRoom,
      subscribeTopic: (topic, onEvent) => this._reactor.subscribeTopic(roomId, topic, onEvent),
      subscribePresence: (opts, onChange) => this._reactor.subscribePresence(roomType, roomId, opts, onChange),
      publishTopic: (topic, data) => this._reactor.publishTopic({ roomType, roomId, topic, data }),
      publishPresence: (data) => this._reactor.publishPresence(roomType, roomId, data),
      getPresence: (opts) => this._reactor.getPresence(roomType, roomId, opts)
    };
  }
  shutdown() {
    delete globalInstantCoreStore[this._reactor.config.appId];
    this._reactor.shutdown();
  }
  /**
   * Use this for one-off queries.
   * Returns local data if available, otherwise fetches from the server.
   * Because we want to avoid stale data, this method will throw an error
   * if the user is offline or there is no active connection to the server.
   *
   * @see https://instantdb.com/docs/instaql
   *
   * @example
   *
   *  const resp = await db.queryOnce({ goals: {} });
   *  console.log(resp.data.goals)
   */
  queryOnce(query3) {
    return this._reactor.queryOnce(query3);
  }
};
var Auth = class {
  constructor(db) {
    this.db = db;
    this.sendMagicCode = (params) => {
      return this.db.sendMagicCode(params);
    };
    this.signInWithMagicCode = (params) => {
      return this.db.signInWithMagicCode(params);
    };
    this.signInWithToken = (token) => {
      return this.db.signInWithCustomToken(token);
    };
    this.createAuthorizationURL = (params) => {
      return this.db.createAuthorizationURL(params);
    };
    this.signInWithIdToken = (params) => {
      return this.db.signInWithIdToken(params);
    };
    this.exchangeOAuthCode = (params) => {
      return this.db.exchangeCodeForToken(params);
    };
    this.issuerURI = () => {
      return this.db.issuerURI();
    };
    this.signOut = () => {
      return this.db.signOut();
    };
  }
};
var Storage = class {
  constructor(db) {
    this.db = db;
    this.upload = (pathname, file) => {
      return this.db.upload(pathname, file);
    };
    this.put = this.upload;
    this.getDownloadUrl = (pathname) => {
      return this.db.getDownloadUrl(pathname);
    };
    this.delete = (pathname) => {
      return this.db.deleteFile(pathname);
    };
  }
};
function coerceQuery(o) {
  return JSON.parse(JSON.stringify(o));
}

// ../node_modules/@instantdb/react/dist/module/InstantReact.js
var import_react3 = __toESM(require_react());

// ../node_modules/@instantdb/react/dist/module/useQuery.js
var import_react = __toESM(require_react());
var defaultState = {
  isLoading: true,
  data: void 0,
  pageInfo: void 0,
  error: void 0
};
function stateForResult(result) {
  return Object.assign({ isLoading: !Boolean(result), data: void 0, pageInfo: void 0, error: void 0 }, result ? result : {});
}
function useQuery(_core, _query) {
  const query3 = _query ? coerceQuery(_query) : null;
  const queryHash = weakHash_default(query3);
  const resultCacheRef = (0, import_react.useRef)(stateForResult(_core._reactor.getPreviousResult(query3)));
  const subscribe = (0, import_react.useCallback)(
    (cb) => {
      if (!query3) {
        const unsubscribe2 = () => {
        };
        return unsubscribe2;
      }
      const unsubscribe = _core.subscribeQuery(query3, (result) => {
        resultCacheRef.current = Object.assign({ isLoading: !Boolean(result), data: void 0, pageInfo: void 0, error: void 0 }, result);
        cb();
      });
      return unsubscribe;
    },
    // Build a new subscribe function if the query changes
    [queryHash]
  );
  const state = (0, import_react.useSyncExternalStore)(subscribe, () => resultCacheRef.current, () => defaultState);
  return { state, query: query3 };
}

// ../node_modules/@instantdb/react/dist/module/useTimeout.js
var import_react2 = __toESM(require_react());
function useTimeout() {
  const timeoutRef = (0, import_react2.useRef)(null);
  (0, import_react2.useEffect)(() => {
    clear();
  }, []);
  function set2(delay, fn) {
    clearTimeout(timeoutRef.current);
    timeoutRef.current = setTimeout(fn, delay);
  }
  function clear() {
    clearTimeout(timeoutRef.current);
  }
  return { set: set2, clear };
}

// ../node_modules/@instantdb/react/dist/module/InstantReact.js
var defaultActivityStopTimeout = 1e3;
var InstantReactRoom = class {
  constructor(_core, type, id2) {
    this.useTopicEffect = (topic, onEvent) => {
      (0, import_react3.useEffect)(() => {
        const unsub = this._core._reactor.subscribeTopic(this.id, topic, (event, peer) => {
          onEvent(event, peer);
        });
        return unsub;
      }, [this.id, topic]);
    };
    this.usePublishTopic = (topic) => {
      (0, import_react3.useEffect)(() => this._core._reactor.joinRoom(this.id), [this.id]);
      const publishTopic = (0, import_react3.useCallback)((data) => {
        this._core._reactor.publishTopic({
          roomType: this.type,
          roomId: this.id,
          topic,
          data
        });
      }, [this.id, topic]);
      return publishTopic;
    };
    this.usePresence = (opts = {}) => {
      var _a, _b;
      const [state, setState] = (0, import_react3.useState)(() => {
        var _a2;
        return (_a2 = this._core._reactor.getPresence(this.type, this.id, opts)) !== null && _a2 !== void 0 ? _a2 : {
          peers: {},
          isLoading: true
        };
      });
      (0, import_react3.useEffect)(() => {
        const unsub = this._core._reactor.subscribePresence(this.type, this.id, opts, (data) => {
          setState(data);
        });
        return unsub;
      }, [this.id, opts.user, (_a = opts.peers) === null || _a === void 0 ? void 0 : _a.join(), (_b = opts.keys) === null || _b === void 0 ? void 0 : _b.join()]);
      return Object.assign(Object.assign({}, state), { publishPresence: (data) => {
        this._core._reactor.publishPresence(this.type, this.id, data);
      } });
    };
    this.useSyncPresence = (data, deps) => {
      (0, import_react3.useEffect)(() => this._core._reactor.joinRoom(this.id), [this.id]);
      (0, import_react3.useEffect)(() => {
        return this._core._reactor.publishPresence(this.type, this.id, data);
      }, [this.type, this.id, deps !== null && deps !== void 0 ? deps : JSON.stringify(data)]);
    };
    this.useTypingIndicator = (inputName, opts = {}) => {
      const timeout = useTimeout();
      const onservedPresence = this.usePresence({
        keys: [inputName]
      });
      const active = (0, import_react3.useMemo)(() => {
        var _a;
        const presenceSnapshot = this._core._reactor.getPresence(this.type, this.id);
        return (opts === null || opts === void 0 ? void 0 : opts.writeOnly) ? [] : Object.values((_a = presenceSnapshot === null || presenceSnapshot === void 0 ? void 0 : presenceSnapshot.peers) !== null && _a !== void 0 ? _a : {}).filter((p) => p[inputName] === true);
      }, [opts === null || opts === void 0 ? void 0 : opts.writeOnly, onservedPresence]);
      const setActive = (isActive) => {
        var _a;
        this._core._reactor.publishPresence(this.type, this.id, {
          [inputName]: isActive
        });
        if (!isActive)
          return;
        if ((opts === null || opts === void 0 ? void 0 : opts.timeout) === null || (opts === null || opts === void 0 ? void 0 : opts.timeout) === 0)
          return;
        timeout.set((_a = opts === null || opts === void 0 ? void 0 : opts.timeout) !== null && _a !== void 0 ? _a : defaultActivityStopTimeout, () => {
          this._core._reactor.publishPresence(this.type, this.id, {
            [inputName]: null
          });
        });
      };
      return {
        active,
        setActive: (a) => {
          setActive(a);
        },
        inputProps: {
          onKeyDown: (e) => {
            const isEnter = (opts === null || opts === void 0 ? void 0 : opts.stopOnEnter) && e.key === "Enter";
            const isActive = !isEnter;
            setActive(isActive);
          },
          onBlur: () => {
            setActive(false);
          }
        }
      };
    };
    this._core = _core;
    this.type = type;
    this.id = id2;
  }
};
var defaultAuthState = {
  isLoading: true,
  user: void 0,
  error: void 0
};
var InstantReact = class {
  constructor(config) {
    this.tx = txInit();
    this.getLocalId = (name) => {
      return this._core.getLocalId(name);
    };
    this.transact = (chunks) => {
      return this._core.transact(chunks);
    };
    this.useQuery = (query3) => {
      return useQuery(this._core, query3).state;
    };
    this.useAuth = () => {
      const resultCacheRef = (0, import_react3.useRef)(this._core._reactor._currentUserCached);
      const subscribe = (0, import_react3.useCallback)((cb) => {
        const unsubscribe = this._core.subscribeAuth((auth) => {
          resultCacheRef.current = Object.assign({ isLoading: false }, auth);
          cb();
        });
        return unsubscribe;
      }, []);
      const state = (0, import_react3.useSyncExternalStore)(subscribe, () => resultCacheRef.current, () => defaultAuthState);
      return state;
    };
    this.queryOnce = (query3) => {
      return this._core.queryOnce(query3);
    };
    this._core = _init_internal(
      config,
      // @ts-expect-error because TS can't resolve subclass statics
      this.constructor.Storage,
      // @ts-expect-error because TS can't resolve subclass statics
      this.constructor.NetworkListener
    );
    this.auth = this._core.auth;
    this.storage = this._core.storage;
  }
  /**
   * Obtain a handle to a room, which allows you to listen to topics and presence data
   *
   * If you don't provide a `type` or `id`, Instant will default to `_defaultRoomType` and `_defaultRoomId`
   * as the room type and id, respectively.
   *
   * @see https://instantdb.com/docs/presence-and-topics
   *
   * @example
   *  const {
   *   useTopicEffect,
   *   usePublishTopic,
   *   useSyncPresence,
   *   useTypingIndicator,
   * } = db.room(roomType, roomId);
   */
  room(type = "_defaultRoomType", id2 = "_defaultRoomId") {
    return new InstantReactRoom(this._core, type, id2);
  }
};

// ../node_modules/@instantdb/react/dist/module/InstantReactWeb.js
var InstantReactWeb = class extends InstantReact {
};

// ../node_modules/@instantdb/react/dist/module/init.js
function init(config) {
  return new InstantReactWeb(config);
}
function init_experimental(config) {
  return new InstantReactWeb(config);
}

// ../node_modules/@instantdb/react/dist/module/Cursors.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react4 = __toESM(require_react());
function Cursors({ as = "div", spaceId: _spaceId, room, className, style, userCursorColor, children, renderCursor, propagate, zIndex }) {
  const spaceId = _spaceId || `cursors-space-default--${String(room.type)}-${room.id}`;
  const cursorsPresence = room.usePresence({
    keys: [spaceId]
  });
  const fullPresence = room._core._reactor.getPresence(room.type, room.id);
  function onMouseMove(e) {
    if (!propagate) {
      e.stopPropagation();
    }
    const rect = e.currentTarget.getBoundingClientRect();
    const x = e.clientX;
    const y = e.clientY;
    const xPercent = (x - rect.left) / rect.width * 100;
    const yPercent = (y - rect.top) / rect.height * 100;
    cursorsPresence.publishPresence({
      [spaceId]: {
        x,
        y,
        xPercent,
        yPercent,
        color: userCursorColor
      }
    });
  }
  function onMouseOut(e) {
    cursorsPresence.publishPresence({
      [spaceId]: void 0
    });
  }
  return (0, import_react4.createElement)(as, {
    onMouseMove,
    onMouseOut,
    className,
    style: Object.assign({ position: "relative" }, style)
  }, [
    children,
    (0, import_jsx_runtime.jsx)("div", { style: Object.assign(Object.assign(Object.assign({}, absStyles), inertStyles), { zIndex: zIndex !== void 0 ? zIndex : defaultZ }), children: Object.entries(cursorsPresence.peers).map(([id2, presence]) => {
      const cursor = presence[spaceId];
      if (!cursor)
        return null;
      return (0, import_jsx_runtime.jsx)("div", { style: Object.assign(Object.assign({}, absStyles), { transform: `translate(${cursor.xPercent}%, ${cursor.yPercent}%)`, transformOrigin: "0 0", transition: "transform 100ms" }), children: renderCursor ? renderCursor({
        color: cursor.color,
        presence: fullPresence.peers[id2]
      }) : (0, import_jsx_runtime.jsx)(Cursor, Object.assign({}, cursor)) }, id2);
    }) }, spaceId)
  ]);
}
function Cursor({ color }) {
  const size = 35;
  const fill = color || "black";
  return (0, import_jsx_runtime.jsxs)("svg", { style: { height: size, width: size }, viewBox: `0 0 ${size} ${size}`, fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [(0, import_jsx_runtime.jsxs)("g", { fill: "rgba(0,0,0,.2)", transform: "matrix(1, 0, 0, 1, -11.999999046325684, -8.406899452209473)", children: [(0, import_jsx_runtime.jsx)("path", { d: "m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z" }), (0, import_jsx_runtime.jsx)("path", { d: "m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z" })] }), (0, import_jsx_runtime.jsxs)("g", { fill: "white", transform: "matrix(1, 0, 0, 1, -11.999999046325684, -8.406899452209473)", children: [(0, import_jsx_runtime.jsx)("path", { d: "m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z" }), (0, import_jsx_runtime.jsx)("path", { d: "m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z" })] }), (0, import_jsx_runtime.jsxs)("g", { fill, transform: "matrix(1, 0, 0, 1, -11.999999046325684, -8.406899452209473)", children: [(0, import_jsx_runtime.jsx)("path", { d: "m19.751 24.4155-1.844.774-3.1-7.374 1.841-.775z" }), (0, import_jsx_runtime.jsx)("path", { d: "m13 10.814v11.188l2.969-2.866.428-.139h4.768z" })] })] });
}
var absStyles = {
  position: "absolute",
  top: 0,
  left: 0,
  bottom: 0,
  right: 0
};
var inertStyles = {
  overflow: "hidden",
  pointerEvents: "none",
  userSelect: "none"
};
var defaultZ = 99999;
export {
  Cursors,
  InstantReact,
  InstantReactWeb,
  i,
  uuid_default as id,
  init,
  init_experimental,
  lookup,
  tx
};
//# sourceMappingURL=@instantdb_react.js.map
